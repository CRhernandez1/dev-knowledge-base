{"config":{"separator":"[\\s\\-_,:!=\\[\\]()\\\\\"`/]+|\\.(?!\\d)"},"items":[{"location":"","level":1,"title":"P√°gina de Inicio","text":"","path":["P√°gina de Inicio"],"tags":[]},{"location":"java-script/","level":1,"title":"JavaScript","text":"","path":["JavaScript"],"tags":[]},{"location":"java-script/#variables","level":2,"title":"Variables","text":"Declaraci√≥n ¬øReasignable? Scope (Alcance) Uso recomendado const ‚ùå No Block Scope <code>{}</code> Por defecto (95%) let ‚úÖ S√≠ Block Scope <code>{}</code> Solo si el valor cambiar√° var ‚úÖ S√≠ Function Scope NUNCA (Legacy)","path":["JavaScript"],"tags":[]},{"location":"java-script/#tipos-de-datos-primitivos","level":2,"title":"Tipos de datos (Primitivos)","text":"<p>Podr√≠amos definir primitivos como tipos de datos inmutables que no se asemejan a los objetos.</p> <ol> <li>Number: Todo son flotantes (<code>10</code> y <code>10.5</code> son el mismo tipo). No hay <code>int</code> vs <code>float</code>.</li> <li>String: Una cadena de c√°racteres, que forma una palabra. (Ej: 'manzana').</li> <li>Boolean: <code>true</code> / <code>false</code> (Ojo: en min√∫sculas).</li> <li>Undefined: Valor de una variable declarada pero a√∫n no definida. (Ej: <code>let x;</code>).</li> <li>Null: Valor intencionalmente vac√≠o. (Curiosidad \"typeof symbol\", mostrar√° object)</li> <li>Symbol: (ES6) Es un valor √∫nico que no se iguala a ning√∫n otro valor.</li> <li>BigInt: (ES2020) Para enteros gigantes.</li> </ol>","path":["JavaScript"],"tags":[]},{"location":"java-script/#expressions-y-statements","level":2,"title":"Expressions y Statements","text":"","path":["JavaScript"],"tags":[]},{"location":"java-script/#expressions-expresiones","level":3,"title":"Expressions (Expresiones)","text":"<p>Definici√≥n: Cualquier unidad de c√≥digo que produce un valor. Piensa en ellas como algo que responde a una pregunta. Si puedes ponerlo en el lado derecho de una asignaci√≥n (<code>=</code>), es una expresi√≥n.</p> <ul> <li>Ejemplos:<ul> <li><code>3 + 4</code> (Produce <code>7</code>)</li> <li><code>1991</code> (Produce <code>1991</code>)</li> <li><code>true &amp;&amp; false</code> (Produce <code>false</code>)</li> <li><code>miFuncion()</code> (Si la funci√≥n retorna algo, la llamada es una expresi√≥n).</li> </ul> </li> </ul> <p>La prueba de fuego: Si puedes ponerlo dentro de un console.log( ... ), es una expresi√≥n.</p>","path":["JavaScript"],"tags":[]},{"location":"java-script/#statements-sentencias-declaraciones","level":3,"title":"Statements (Sentencias / Declaraciones)","text":"<p>Definici√≥n: Es una instrucci√≥n completa, una acci√≥n. Hacen cosas, pero no producen un valor inmediato que puedas asignar a una variable. Piensa en ellas como una \"oraci√≥n completa\" que termina en punto y coma (<code>;</code>).</p> <ul> <li>Ejemplos:<ul> <li><code>if (else) { ... }</code> (Es una estructura de control, no devuelve un valor).</li> <li><code>switch</code></li> <li><code>for</code> / <code>while</code></li> <li><code>const x = 5;</code> (Toda la l√≠nea es una statement, aunque <code>5</code> sea una expression).</li> </ul> </li> </ul> <p>La prueba de fuego: No puedes hacer esto: const resultado = if (x &gt; 0) { return 1 }. Eso dar√≠a error, porque un if es un Statement.</p>","path":["JavaScript"],"tags":[]},{"location":"java-script/#comentarios","level":2,"title":"Comentarios","text":"<ol> <li>L√≠nea simple: Para notas breves.</li> <li>Bloque: Para explicaciones largas o deshabilitar c√≥digo.</li> </ol> <pre><code>// 1. Comentario de una sola l√≠nea\nconst usuario = 'Dev'; // Tambi√©n sirve al final de una instrucci√≥n\n\n/*\n  2. Comentario de bloque (Multi-l√≠nea)\n  Todo lo que est√© aqu√≠ dentro ser√° ignorado.\n  √ötil para notas extensas o 'apagar' secciones de c√≥digo.\n*/\n</code></pre>","path":["JavaScript"],"tags":[]},{"location":"java-script/#comillas","level":2,"title":"Comillas","text":"<p>En JavaScript, hay 3 tipos de comillas.</p> <ul> <li>Comillas dobles: \"Hola\"</li> <li>Comillas simples: 'Hola'</li> <li>Backticks (comillas invertidas): `Hola`</li> </ul> <p>Las comillas dobles y simples son comillas ‚Äúsencillas‚Äù (es decir, funcionan igual). No hay diferencia entre ellas en JavaScript. Queda a elecci√≥n del programador cual usar, pero por lo general se recomiendan las simples.</p> <p>Los backticks son comillas de interpolaci√≥n. Nos permiten inyectar variables y expresiones en una cadena de caracteres encerr√°ndolas en ${...}, por ejemplo:</p> <pre><code>const fistName = 'Cristian';\nconsole.log(`Hello, ${name}`);\n</code></pre>","path":["JavaScript"],"tags":[]},{"location":"java-script/#conversion-de-tipos","level":2,"title":"Conversi√≥n de tipos","text":"","path":["JavaScript"],"tags":[]},{"location":"java-script/#type-conversion-vs-type-coercion","level":3,"title":"Type Conversion vs. Type Coercion","text":"<p>Aqu√≠ es donde JS se vuelve \"raro\".</p> <ul> <li>Conversion: Manual. <code>Number('1991')</code>, <code>String(23)</code>.</li> <li>Coercion: Autom√°tica (JS lo hace por ti a escondidas).</li> </ul> <p>Las reglas del caos:</p> <ol> <li>El operador <code>+</code> convierte n√∫meros a Strings si hay un string presente.</li> <li>Los operadores <code>-</code>, <code>*</code> , <code>/</code> convierten strings a N√∫meros.</li> </ol> <pre><code>console.log('I am ' + 23 + ' years old'); // 'I am 23 years old' (Todo a String)\nconsole.log('23' - '10' - 3);             // 10 (Todo a Number)\nconsole.log('23' + '10' + 3);             // '23103' (Concatenaci√≥n)\nconsole.log('4' * '2');                   // 8 (Number)  \nconsole.log(+'7')                         // 7 (Ojo: Aqu√≠ lo convierte a Number)\n</code></pre>","path":["JavaScript"],"tags":[]},{"location":"java-script/#conversiones-boolean-string-number","level":3,"title":"Conversiones (Boolean, String, Number)","text":"","path":["JavaScript"],"tags":[]},{"location":"java-script/#conversion-a-string","level":4,"title":"Conversi√≥n a String","text":"<p>Ocurre cuando queremos la representaci√≥n visual de un valor. Su uso m√°s com√∫n es para pasar de n√∫meros a string, de forma expl√≠cita.</p> <pre><code>console.log(String(false));     // \"false\"\nconsole.log(String(null));      // \"null\"\nconsole.log(String(undefined)); // \"undefined\"\nconsole.log(String(123));       // \"123\"\n</code></pre>","path":["JavaScript"],"tags":[]},{"location":"java-script/#conversion-a-number","level":4,"title":"Conversi√≥n a Number","text":"<p>Para convertir de forma expl√≠cita a Number se har√≠a de esta manera.</p> <pre><code>let str = \"98\";\nalert(typeof str); // string\n\nlet num = Number(str); // se convierte en 98\nlet conversionError = Number('754z') //Leer algo distinto a Number como la z, dar√° NaN\nlet emptyString = Number('') // Es cero\n</code></pre> <p>Dependiendo del tipo del valor a convertir tiene sus rarezas: </p> Valor de entrada Se convierte en‚Ä¶ Notas <code>undefined</code> <code>NaN</code> No es un n√∫mero v√°lido. <code>null</code> <code>0</code> Se trata como \"nada\" o vac√≠o num√©rico. <code>true</code> / <code>false</code> <code>1</code> / <code>0</code> Booleans binarios. <code>string</code> <code>0</code>, <code>Number</code> o <code>NaN</code> Se limpian los espacios antes de convertir.","path":["JavaScript"],"tags":[]},{"location":"java-script/#conversion-a-booleano","level":4,"title":"Conversi√≥n a Booleano","text":"<p>Los valores conocidos como falsy, que se explicar√°n a continuaci√≥n, se evaluan a false. Mientras el resto eval√∫a como true</p>","path":["JavaScript"],"tags":[]},{"location":"java-script/#truthy-falsy-values","level":2,"title":"Truthy &amp; Falsy Values","text":"<p>JS intenta convertir cualquier cosa a booleano si lo pones en un <code>if</code>.</p> <p>Los 5 valores Falsy (Se convierten a <code>false</code>):</p> <ol> <li><code>0</code></li> <li><code>''</code> (String vac√≠o)</li> <li><code>undefined</code></li> <li><code>null</code></li> <li><code>NaN</code> (Not a Number)</li> </ol> <p>Todo lo dem√°s es Truthy.</p> <p>‚ö†Ô∏è En JS, un array vac√≠o [] y objeto vac√≠o {} son true.</p>","path":["JavaScript"],"tags":[]},{"location":"java-script/#operadores","level":2,"title":"Operadores","text":"","path":["JavaScript"],"tags":[]},{"location":"java-script/#operadores-aritmeticos","level":3,"title":"Operadores Ar√≠tmeticos","text":"<p>Antes que nada es importante distinguir cuando un operador es unario y cuando binario. Si el operador solo tiene un operando, se considera unario.</p> <pre><code>const number = 5;\nconsole.log(-number) // Lo convierte a negativo, -5\nconsole.log(+'5') // Lo convierte a Number, 5\n</code></pre> <p>Los binarios operan como en la matem√°tica tradicional, y tenemos los siguientes:</p> Operador Precedencia Asociatividad Ejemplo <code>**</code> 13 Derecha a Izquierda ‚¨ÖÔ∏è <code>2 ** 3 ** 2</code> ‚ûî <code>512</code> <code>*</code> 12 Izquierda a Derecha ‚û°Ô∏è <code>2 * 3 * 2</code> ‚ûî <code>12</code> <code>/</code> 12 Izquierda a Derecha ‚û°Ô∏è <code>10 / 2 / 5</code> ‚ûî <code>1</code> <code>%</code> 12 Izquierda a Derecha ‚û°Ô∏è <code>10 % 3</code> ‚ûî <code>1</code> <code>+</code> 11 Izquierda a Derecha ‚û°Ô∏è <code>1 + 2</code> ‚ûî <code>3</code> <code>-</code> 11 Izquierda a Derecha ‚û°Ô∏è <code>5 - 2</code> ‚ûî <code>3</code> <p>Cabe destacar, que funcionan as√≠ cuando los dos operando son Numbers, sino se empezar√≠an a aplicar las reglas que hemos visto anteriormente de \"coercion\". Por ejemplo el operador \"+\", fuera del √°mbito ar√≠tmetico en JS tambi√©n sirve para concatenar strings.</p>","path":["JavaScript"],"tags":[]},{"location":"java-script/#operadores-logicos","level":3,"title":"Operadores L√≥gicos","text":"<ul> <li><code>and</code> -&gt; <code>&amp;&amp;</code></li> <li><code>or</code> -&gt; <code>||</code></li> <li><code>not</code> -&gt; <code>!</code></li> </ul>","path":["JavaScript"],"tags":[]},{"location":"java-script/#operador-nullish-coalescing","level":3,"title":"Operador Nullish Coalescing '??'","text":"<p>El operador <code>||</code> puede genear problemas cuando solo queremos evaluar si algo es undefined o null, ya que tambi√©n cuenta el <code>0</code> o <code>''</code> como false.</p> <p>El operador nullish arregla esto, ya que solo eval√∫a como falso, undefined y null.</p> <pre><code>const myMark = 0;\n\nmyMark || 'No se ha corregido' //En este caso si que tiene nota, tiene un 0, por lo que fallar√≠a.\nmyMark ?? 'No se ha corregido' // En este caso mostrar√≠a correctamente el 0 como nota.\n</code></pre>","path":["JavaScript"],"tags":[]},{"location":"java-script/#operador-ternario-y-typeof","level":3,"title":"Operador ternario y typeof","text":"<p><code>typeof</code> es un operador especial que sirve para saber el tipo de dato de un valor o variable.</p> <p><pre><code>const number = 5;\nconsole.log(typeof number) //Number\nconsole.log(typeof '7') //String\n</code></pre> El operador ternanrio sirve para expresar un condicional de una manera m√°s compacta.</p> <pre><code>const age = 24;\nconst isAdult = 24 &gt;= 18 ? 'Es mayor de edad' : 'Es menor de edad';\nconsole.log(isAdult); //Es mayor de edad\n</code></pre>","path":["JavaScript"],"tags":[]},{"location":"java-script/#precedence","level":3,"title":"Precedence","text":"<p>Todo los operadores se rigen a unas normas para establecer cuales se aplican antes. Esto lo podemos ver m√°s en profundidad. En la documentaci√≥n.</p> <p>El par√©ntesis tiene la precedencia m√°s alta, asi que lo podemos usar como lo har√≠amos en matem√°ticas, cuando sea necesario, o para aclarar el orden visual de las operaciones para las futuras personas que puedan leer el c√≥digo.</p>","path":["JavaScript"],"tags":[]},{"location":"java-script/#short-circuiting-y","level":2,"title":"Short Circuiting (&amp;&amp; y ||)","text":"<p>En JS, estos operadores no devuelven <code>true/false</code>, devuelven el valor.</p>","path":["JavaScript"],"tags":[]},{"location":"java-script/#or","level":3,"title":"OR (<code>||</code>)","text":"<p>Devuelve el primer valor TRUTHY que encuentre. Si todos son falsos, devuelve el √∫ltimo.</p> <ul> <li>Uso antiguo: Asignar valores por defecto.</li> </ul> <pre><code>// Si restaurant.guests es 0, undefined o null... guests1 ser√° 10.\nconst guests1 = restaurant.numGuests || 10;\n</code></pre> <ul> <li>‚ö†Ô∏è Bug: Si <code>numGuests</code> es <code>0</code> (un n√∫mero v√°lido de invitados), JS lo toma como falsy y pone 10. Error l√≥gico grave. Para esto fue dise√±ado el operador nullish explicado anteriormente.</li> </ul>","path":["JavaScript"],"tags":[]},{"location":"java-script/#and","level":3,"title":"AND (<code>&amp;&amp;</code>)","text":"<p>Devuelve el primer valor FALSY. Si todos son verdaderos, devuelve el √∫ltimo.</p> <ul> <li>Uso: Reemplazar <code>if</code> simples.</li> </ul> <pre><code>// Si orderPizza existe, ejec√∫tala. Si no, no hagas nada.\nrestaurant.orderPizza &amp;&amp; restaurant.orderPizza('Mushrooms');\n</code></pre>","path":["JavaScript"],"tags":[]},{"location":"java-script/#equality-operators-vs","level":2,"title":"Equality Operators: <code>==</code> vs <code>===</code>","text":"<p>El <code>===</code> a diferencia de los dos iguales comprueba que el tipo de dato y el valor sean iguales, mientras que el otro solo se fija en el valor, no le importa que tipo de dato sea, porque realiza coerci√≥n.</p> <ul> <li><code>==</code> (Loose equality): Hace Coerci√≥n de tipo. <code>'18' == 18</code> es <code>true</code>. No es recomendable.</li> <li><code>===</code> (Strict equality): No hace coerci√≥n. <code>'18' === 18</code> es <code>false</code>. Es preferible usar este aunque haya que hacer conversiones expl√≠citas.</li> </ul> <pre><code>const num = '18';\nif (num === 18) console.log('Strict'); // False (String != Number)\nif (num == 18)  console.log('Loose');  // True (JS convierte string a numero)`\n</code></pre>","path":["JavaScript"],"tags":[]},{"location":"java-script/#condicionales-y-switch","level":2,"title":"Condicionales y Switch","text":"","path":["JavaScript"],"tags":[]},{"location":"java-script/#if-else","level":3,"title":"if - else","text":"<p>En JS por lo general el codigo que se ejecutar√° al evaluarse una condici√≥n va entre llaves, salvo que solo se quiera ejecutar una sentencia que en este caso se podr√≠an omitir las llaves. Pero por lo general se recomienda usar las llaves</p> <pre><code>const myMark = 7;\n\nif (myMark &gt;= 5) console.log('Aprobado'); // Sin llaves\n\nif (myMark &gt;= 5) {\n    console.log('Aprobado') // Con llaves (opcional)\n}\n\nif (myMark &gt;= 5) {\n    const result = 'Aprobado';\n    console.log(result); // Con llaves (obligario, por ser m√°s de una sentencia)\n}\n</code></pre> <p>La estructura general de los condicionales no cambian mucho con respecto a otros lenguajes.</p> <pre><code>const age = 25;\nif (age &gt; 18) {\n    console.log('Mayor de 18');\n} else if (age &lt; 18) {\n    console.log('Menor de 18');\n} else {\n    console.log('Tiene exactamente 18');\n}\n\n// Tambi√©n se podr√≠a expresar as√≠, porque en este caso solo es una stament por bloque.\n\nif (age &gt; 18) console.log('Mayor de 18');\nelse if (age &lt; 18) console.log('Menor de 18');\nelse console.log('Exactamente 18');\n</code></pre>","path":["JavaScript"],"tags":[]},{"location":"java-script/#switch","level":3,"title":"Switch","text":"<p>Cada vez se usa menos, pero es importante conocerlo.</p> <ul> <li>Usa comparaci√≥n estricta (<code>===</code>).</li> <li>¬°Necesita <code>break</code> al final de cada caso o ejecuta el siguiente!</li> </ul> <p>JavaScript</p> <p><code>const day = 'monday'; switch(day) {     case 'monday': // day === 'monday'         console.log('Plan course structure');         break; // ¬°Importante! case:     default:         console.log('Not a valid day'); }</code></p>","path":["JavaScript"],"tags":[]},{"location":"java-script/#agrupar-varios-case-fall-through","level":4,"title":"Agrupar varios <code>case</code> (Fall-through)","text":"<p>En JavaScript, si no pones la palabra <code>break</code>, el c√≥digo \"cae\" hacia abajo y ejecuta el siguiente caso. Esto se usa para agrupar l√≥gica.</p> <p>Escenario: Clasificar d√≠as en Laborales vs. Fin de semana.</p> <pre><code>const day = 'wednesday';\n\nswitch (day) {\n    case 'monday': // No hay break, sigue bajando\n    case 'tuesday':\n    case 'wednesday':\n    case 'thursday':\n    case 'friday':\n        console.log('üìÖ Es d√≠a laboral, a trabajar!');\n        // Aqu√≠ S√ç ponemos break para que pare y no siga bajando\n        break;\n\n    case 'saturday':\n    case 'sunday':\n        console.log('üéâ Es fin de semana, descansa.');\n        break;\n\n    default:\n        console.log('‚ùå Ese d√≠a no existe.');\n}\n</code></pre>","path":["JavaScript"],"tags":[]},{"location":"java-script/#usar-comparaciones-con-switchtrue","level":4,"title":"Usar comparaciones (<code>&gt;=</code>, <code>&lt;</code>, <code>&amp;&amp;</code>) con <code>switch(true)</code>","text":"<p>El <code>switch</code> est√°ndar de JS compara valores exactos (<code>===</code>). No puedes hacer <code>case age &gt; 18</code> directamente.</p> <p>Para lograr esto, usamos un \"Hack\" muy com√∫n: Hacemos el switch sobre el valor <code>true</code>. JS preguntar√°: \"¬øEs <code>true</code> igual a la condici√≥n de este caso?\".</p> <p>Escenario: Clasificar por rangos de edad.</p> <pre><code>const age = 25;\n\n// Truco: Hacemos switch sobre 'true'\nswitch (true) {\n    case age &gt;= 18 &amp;&amp; age &lt; 65:\n        console.log('üßë Adulto en edad laboral');\n        break;\n\n    case age &gt;= 65:\n        console.log('üë¥ Jubilado');\n        break;\n\n    case age &lt; 18 &amp;&amp; age &gt;= 0:\n        console.log('üë∂ Menor de edad');\n        break;\n\n    default:\n        console.log('üëª Edad no v√°lida');\n}\n</code></pre> <p>La mayor√≠a de veces es mejor usar un if-else que recurrir a un switch(true)</p>","path":["JavaScript"],"tags":[]},{"location":"java-script/#bucles","level":2,"title":"Bucles","text":"","path":["JavaScript"],"tags":[]},{"location":"java-script/#bucle-for","level":3,"title":"Bucle for","text":"","path":["JavaScript"],"tags":[]},{"location":"java-script/#tradicional","level":4,"title":"Tradicional","text":"<pre><code>for (begin; condition; step) {\n    // codigo\n}\n</code></pre> <p><pre><code>for (let i = 0; i &lt; 10; i++) {\n    console.log(i);\n}\n</code></pre> - Primero se inicializa una varible, con let porque cambiara en cada iteraci√≥n. - A continuaci√≥n se comprueba la condici√≥n si 0 &lt; 10. - Si es verdad se ejecuta el codigo definido dentro del bloque. - Despu√©s se le suma 1 y se pasa a la siguiente iteraci√≥n. - Esto continua en bucle, de ah√≠ su nombre, hasta que no se cumpla la condici√≥n.</p> <p>Curiosidad: No se suele usar, pero se pueden omitir partes del bucle. Ejemplo: for(;;){}</p>","path":["JavaScript"],"tags":[]},{"location":"java-script/#for-of","level":4,"title":"for of","text":"<pre><code>const animals = ['gato', 'perro', 'gallina']\nfor (const animal of animals) {\n    console.log(animal); // En este bucle se muestra cada elemento de la lista. Una similitud ser√≠a el for de Python\n}\n</code></pre>","path":["JavaScript"],"tags":[]},{"location":"java-script/#while","level":3,"title":"While","text":"","path":["JavaScript"],"tags":[]},{"location":"java-script/#while-comun","level":4,"title":"While com√∫n","text":"<p>Es el while de todo la vida, se suele usar cuando no sabes cuantas veces tendr√°s que iterar.</p> <pre><code>let tries = 0;\n\nwhile (tries &lt; 3) {\n    console.log(`${tries}`)\n    tries++;\n}\n\n// Tambi√©n se puede hacer. Pero suele ser peor pr√°ctica. No es recomendable, salv√≥ casos necesarios.\nwhile (true) {\n    if (tries === 3) {\n        break;\n    }\n    console.log(`${tries}`)\n    tries++;\n}\n</code></pre>","path":["JavaScript"],"tags":[]},{"location":"java-script/#do-while","level":4,"title":"Do While","text":"<p>Es similar al bucle <code>while</code>, pero con una diferencia crucial: garantiza que el bloque de c√≥digo se ejecute al menos una vez.</p> <p>Primero ejecuta el cuerpo del bucle y despu√©s eval√∫a la condici√≥n. Es ideal para validar datos de entrada (como un <code>prompt</code>), ya que necesitamos preguntar al usuario al menos una vez antes de decidir si volvemos a preguntar.</p> <pre><code>let number; // Definimos number fuera, porque si lo hacemos dentro de las llaves no ser√° accesible desde el exterior.\n\ndo {\n    number = Number(prompt('Introduce un numero del 1 al 10'));\n    // El bucle se repite SI el n√∫mero es menor a 1 O mayor a 10\n} while (number &lt; 0 || number &gt; 10);\n</code></pre>","path":["JavaScript"],"tags":[]},{"location":"java-script/standard-built-in-objects/","level":1,"title":"Standard Built-in Objects","text":"","path":["JavaScript","Standard Built-in Objects"],"tags":[]},{"location":"java-script/standard-built-in-objects/#introduccion","level":2,"title":"Introducci√≥n","text":"<p>En JavaScript, no empiezas desde cero. El lenguaje viene con una \"caja de herramientas\" preinstalada lista para usar en cualquier parte de tu c√≥digo, sin necesidad de importar librer√≠as externas. A estos se les llama Objetos Est√°ndar Incorporados.</p> <p>¬øQu√© son exactamente?</p> <p>Son objetos que existen en el √°mbito global (Global Scope). Esto significa que est√°n disponibles en cualquier script y en cualquier momento.</p> <p>Se dividen principalmente en tres categor√≠as:</p> <ol> <li>Envoltorios de Primitivos: Objetos que nos permiten tratar datos simples (texto, n√∫meros) como si fueran objetos complejos (<code>String</code>, <code>Number</code>, <code>Boolean</code>).</li> <li>Estructuras de Datos: Herramientas para organizar informaci√≥n (<code>Array</code>, <code>Map</code>, <code>Set</code>, <code>Object</code>).</li> <li>Utilidades: Objetos que funcionan como una librer√≠a de funciones matem√°ticas, manejo de fechas o procesamiento de datos (<code>Math</code>, <code>Date</code>, <code>JSON</code>).</li> </ol> <p>¬øQu√© nos proporcionan?</p> <p>Estos objetos nos facilitan la vida proporcionando dos cosas clave: Propiedades (datos) y M√©todos (acciones).</p> <ol> <li> <p>M√©todos de manipulaci√≥n En lugar de escribir una funci√≥n compleja para buscar un texto dentro de otro, el objeto <code>String</code> ya trae <code>.includes()</code>. En lugar de calcular una ra√≠z cuadrada a mano, <code>Math</code> trae <code>.sqrt()</code>.</p> </li> <li> <p>Conversi√≥n de Tipos Nos permiten transformar datos de un tipo a otro de forma segura. Ejemplo: <code>Number(\"10\")</code> convierte un string a n√∫mero.</p> </li> <li> <p>Constantes Universales Valores que nunca cambian y son necesarios matem√°ticamente o por configuraci√≥n. Ejemplo: <code>Math.PI</code> o <code>Number.MAX_VALUE</code>.</p> </li> </ol>","path":["JavaScript","Standard Built-in Objects"],"tags":[]},{"location":"java-script/standard-built-in-objects/#metodos-de-string","level":2,"title":"M√©todos de String","text":"<p>JavaScript proporciona una gran cantidad de m√©todos para manipular texto.</p> <p>‚ö†Ô∏è Inmutabilidad: Recuerda que los Strings en JS son inmutables. Ninguno de estos m√©todos modifica la variable original; todos devuelven un nuevo string con los cambios aplicados.</p> <p>Leyenda de Frecuencia</p> <ul> <li>üü¢ Esencial: De uso diario.</li> <li>üü° Ocasional: Para casos espec√≠ficos.</li> <li>üî¥ Raro / Legacy: Existen formas m√°s modernas o mejores de hacerlo.</li> </ul>","path":["JavaScript","Standard Built-in Objects"],"tags":[]},{"location":"java-script/standard-built-in-objects/#busqueda-y-comprobacion","level":3,"title":"B√∫squeda y Comprobaci√≥n","text":"<p>Responden preguntas sobre el contenido. Devuelven <code>boolean</code> (true/false) o √≠ndices num√©ricos.</p> Uso M√©todo Descripci√≥n Ejemplo üü¢ <code>.includes(txt)</code> ¬øContiene el texto? <code>\"Hola\".includes(\"o\")</code> // <code>true</code> üü¢ <code>.startsWith(txt)</code> ¬øEmpieza por...? <code>\"img.jpg\".startsWith(\"img\")</code> üü¢ <code>.endsWith(txt)</code> ¬øTermina en...? <code>\"file.js\".endsWith(\".js\")</code> üü° <code>.indexOf(txt)</code> Posici√≥n donde empieza (o <code>-1</code>). <code>\"Hola\".indexOf(\"a\")</code> // <code>3</code> üü° <code>.lastIndexOf(txt)</code> Igual, pero busca desde el final. <code>\"anana\".lastIndexOf(\"a\")</code> // <code>4</code> üî¥ <code>.search(regex)</code> Busca con Regex. Suele usarse <code>.match</code>. <code>\"Hola\".search(/H/)</code>","path":["JavaScript","Standard Built-in Objects"],"tags":[]},{"location":"java-script/standard-built-in-objects/#extraccion-y-corte","level":3,"title":"Extracci√≥n y Corte","text":"<p>Para obtener fragmentos del texto o convertirlo en Arrays.</p> Uso M√©todo Descripci√≥n Ejemplo üü¢ <code>.slice(ini, fin)</code> Corta un trozo. Admite negativos. <code>\"React\".slice(0, 2)</code> // <code>\"Re\"</code> üü¢ <code>.split(sep)</code> Divide el texto en un Array. <code>\"a-b\".split(\"-\")</code> // <code>['a','b']</code> üî¥ <code>.substring(ini, fin)</code> Como slice, pero sin negativos. Usa <code>.slice()</code> mejor. ‚õî <code>.substr()</code> Obsoleto. No usar. --","path":["JavaScript","Standard Built-in Objects"],"tags":[]},{"location":"java-script/standard-built-in-objects/#modificacion","level":3,"title":"Modificaci√≥n","text":"<p>Transforman el texto (retornando uno nuevo).</p> Uso M√©todo Descripci√≥n Ejemplo üü¢ <code>.replace(a, b)</code> Reemplaza la primera coincidencia. <code>\"x x\".replace(\"x\", \"y\")</code> // <code>\"y x\"</code> üü¢ <code>.replaceAll(a, b)</code> Reemplaza todas las coincidencias. <code>\"x x\".replaceAll(\"x\", \"y\")</code> // <code>\"y y\"</code> üü¢ <code>.toUpperCase()</code> Convierte a MAY√öSCULAS. <code>\"a\".toUpperCase()</code> // <code>\"A\"</code> üü¢ <code>.toLowerCase()</code> Convierte a min√∫sculas. <code>\"B\".toLowerCase()</code> // <code>\"b\"</code> üü¢ <code>.trim()</code> Quita espacios a los lados. <code>\" x \".trim()</code> // <code>\"x\"</code> üü° <code>.trimStart()</code> Quita espacios solo del inicio. <code>\" x\".trimStart()</code> üü° <code>.repeat(n)</code> Repite el string <code>n</code> veces. <code>\"Ha\".repeat(3)</code> // <code>\"HaHaHa\"</code> üî¥ <code>.concat(str)</code> Une textos. Usa el operador <code>+</code> o Template Strings.","path":["JavaScript","Standard Built-in Objects"],"tags":[]},{"location":"java-script/standard-built-in-objects/#caracteres-y-relleno","level":3,"title":"Caracteres y Relleno","text":"<p>Manipulaci√≥n visual o acceso a caracteres.</p> Uso M√©todo Descripci√≥n Ejemplo üü° <code>.charAt(i)</code> Letra en la posici√≥n <code>i</code>. <code>\"Hola\".charAt(0)</code> // <code>\"H\"</code> üü° <code>.padStart(len, c)</code> Rellena al inicio. <code>\"5\".padStart(2,\"0\")</code> // <code>\"05\"</code> üü° <code>.padEnd(len, c)</code> Rellena al final. <code>\"Hi\".padEnd(4,\".\")</code> // <code>\"Hi..\"</code> üî¥ <code>.charCodeAt(i)</code> Devuelve el c√≥digo Unicode. <code>\"A\".charCodeAt(0)</code> // <code>65</code>","path":["JavaScript","Standard Built-in Objects"],"tags":[]},{"location":"java-script/standard-built-in-objects/#buenas-practicas-modernas","level":3,"title":"Buenas Pr√°cticas Modernas","text":"","path":["JavaScript","Standard Built-in Objects"],"tags":[]},{"location":"java-script/standard-built-in-objects/#slice-vs-substring","level":3,"title":"Slice vs Substring","text":"<p>Usa siempre <code>.slice()</code>. Es m√°s vers√°til porque permite √≠ndices negativos para contar desde el final (ej: \"los √∫ltimos 2 caracteres\").</p> <pre><code>const text = \"JavaScript\";\nconsole.log(text.slice(-6)); // \"Script\"\n// .substring(-6) no funcionar√≠a\n</code></pre>","path":["JavaScript","Standard Built-in Objects"],"tags":[]}]}