{"config":{"separator":"[\\s\\-_,:!=\\[\\]()\\\\\"`/]+|\\.(?!\\d)"},"items":[{"location":"","level":1,"title":"P√°gina de Inicio","text":"","path":["P√°gina de Inicio"],"tags":[]},{"location":"java-script/","level":1,"title":"JavaScript","text":"","path":["JavaScript"],"tags":[]},{"location":"java-script/#variables","level":2,"title":"Variables","text":"Declaraci√≥n ¬øReasignable? Scope (Alcance) Uso recomendado const ‚ùå No Block Scope <code>{}</code> Por defecto (95%) let ‚úÖ S√≠ Block Scope <code>{}</code> Solo si el valor cambiar√° var ‚úÖ S√≠ Function Scope NUNCA (Legacy)","path":["JavaScript"],"tags":[]},{"location":"java-script/#tipos-de-datos-primitivos","level":2,"title":"Tipos de datos (Primitivos)","text":"<p>Podr√≠amos definir primitivos como tipos de datos inmutables que no se asemejan a los objetos.</p> <ol> <li>Number: Todo son flotantes (<code>10</code> y <code>10.5</code> son el mismo tipo). No hay <code>int</code> vs <code>float</code>.</li> <li>String: Una cadena de c√°racteres, que forma una palabra. (Ej: 'manzana').</li> <li>Boolean: <code>true</code> / <code>false</code> (Ojo: en min√∫sculas).</li> <li>Undefined: Valor de una variable declarada pero a√∫n no definida. (Ej: <code>let x;</code>).</li> <li>Null: Valor intencionalmente vac√≠o. (Curiosidad \"typeof symbol\", mostrar√° object)</li> <li>Symbol: (ES6) Es un valor √∫nico que no se iguala a ning√∫n otro valor.</li> <li>BigInt: (ES2020) Para enteros gigantes.</li> </ol>","path":["JavaScript"],"tags":[]},{"location":"java-script/#expressions-y-statements","level":2,"title":"Expressions y Statements","text":"","path":["JavaScript"],"tags":[]},{"location":"java-script/#expressions-expresiones","level":3,"title":"Expressions (Expresiones)","text":"<p>Definici√≥n: Cualquier unidad de c√≥digo que produce un valor. Piensa en ellas como algo que responde a una pregunta. Si puedes ponerlo en el lado derecho de una asignaci√≥n (<code>=</code>), es una expresi√≥n.</p> <ul> <li>Ejemplos:<ul> <li><code>3 + 4</code> (Produce <code>7</code>)</li> <li><code>1991</code> (Produce <code>1991</code>)</li> <li><code>true &amp;&amp; false</code> (Produce <code>false</code>)</li> <li><code>miFuncion()</code> (Si la funci√≥n retorna algo, la llamada es una expresi√≥n).</li> </ul> </li> </ul> <p>La prueba de fuego: Si puedes ponerlo dentro de un console.log( ... ), es una expresi√≥n.</p>","path":["JavaScript"],"tags":[]},{"location":"java-script/#statements-sentencias-declaraciones","level":3,"title":"Statements (Sentencias / Declaraciones)","text":"<p>Definici√≥n: Es una instrucci√≥n completa, una acci√≥n. Hacen cosas, pero no producen un valor inmediato que puedas asignar a una variable. Piensa en ellas como una \"oraci√≥n completa\" que termina en punto y coma (<code>;</code>).</p> <ul> <li>Ejemplos:<ul> <li><code>if (else) { ... }</code> (Es una estructura de control, no devuelve un valor).</li> <li><code>switch</code></li> <li><code>for</code> / <code>while</code></li> <li><code>const x = 5;</code> (Toda la l√≠nea es una statement, aunque <code>5</code> sea una expression).</li> </ul> </li> </ul> <p>La prueba de fuego: No puedes hacer esto: const resultado = if (x &gt; 0) { return 1 }. Eso dar√≠a error, porque un if es un Statement.</p>","path":["JavaScript"],"tags":[]},{"location":"java-script/#comentarios","level":2,"title":"Comentarios","text":"<ol> <li>L√≠nea simple: Para notas breves.</li> <li>Bloque: Para explicaciones largas o deshabilitar c√≥digo.</li> </ol> <pre><code>// 1. Comentario de una sola l√≠nea\nconst usuario = 'Dev'; // Tambi√©n sirve al final de una instrucci√≥n\n\n/*\n  2. Comentario de bloque (Multi-l√≠nea)\n  Todo lo que est√© aqu√≠ dentro ser√° ignorado.\n  √ötil para notas extensas o 'apagar' secciones de c√≥digo.\n*/\n</code></pre>","path":["JavaScript"],"tags":[]},{"location":"java-script/#comillas","level":2,"title":"Comillas","text":"<p>En JavaScript, hay 3 tipos de comillas.</p> <ul> <li>Comillas dobles: \"Hola\"</li> <li>Comillas simples: 'Hola'</li> <li>Backticks (comillas invertidas): `Hola`</li> </ul> <p>Las comillas dobles y simples son comillas ‚Äúsencillas‚Äù (es decir, funcionan igual). No hay diferencia entre ellas en JavaScript. Queda a elecci√≥n del programador cual usar, pero por lo general se recomiendan las simples.</p> <p>Los backticks son comillas de interpolaci√≥n. Nos permiten inyectar variables y expresiones en una cadena de caracteres encerr√°ndolas en ${...}. Adem√°s de hacer strings multil√≠nea.</p> <pre><code>const fistName = 'Cristian';\nconsole.log(`Hello, ${name}`);\n</code></pre>","path":["JavaScript"],"tags":[]},{"location":"java-script/#conversion-de-tipos","level":2,"title":"Conversi√≥n de tipos","text":"","path":["JavaScript"],"tags":[]},{"location":"java-script/#type-conversion-vs-type-coercion","level":3,"title":"Type Conversion vs. Type Coercion","text":"<p>Aqu√≠ es donde JS se vuelve \"raro\".</p> <ul> <li>Conversion: Manual. <code>Number('1991')</code>, <code>String(23)</code>.</li> <li>Coercion: Autom√°tica (JS lo hace por ti a escondidas).</li> </ul> <p>Las reglas del caos:</p> <ol> <li>El operador <code>+</code> convierte n√∫meros a Strings si hay un string presente.</li> <li>Los operadores <code>-</code>, <code>*</code> , <code>/</code> convierten strings a N√∫meros.</li> </ol> <pre><code>console.log('I am ' + 23 + ' years old'); // 'I am 23 years old' (Todo a String)\nconsole.log('23' - '10' - 3);             // 10 (Todo a Number)\nconsole.log('23' + '10' + 3);             // '23103' (Concatenaci√≥n)\nconsole.log('4' * '2');                   // 8 (Number)  \nconsole.log(+'7')                         // 7 (Ojo: Aqu√≠ lo convierte a Number)\n</code></pre>","path":["JavaScript"],"tags":[]},{"location":"java-script/#conversiones-boolean-string-number","level":3,"title":"Conversiones (Boolean, String, Number)","text":"","path":["JavaScript"],"tags":[]},{"location":"java-script/#conversion-a-string","level":4,"title":"Conversi√≥n a String","text":"<p>Ocurre cuando queremos la representaci√≥n visual de un valor. Su uso m√°s com√∫n es para pasar de n√∫meros a string, de forma expl√≠cita.</p> <pre><code>console.log(String(false));     // \"false\"\nconsole.log(String(null));      // \"null\"\nconsole.log(String(undefined)); // \"undefined\"\nconsole.log(String(123));       // \"123\"\n</code></pre>","path":["JavaScript"],"tags":[]},{"location":"java-script/#conversion-a-number","level":4,"title":"Conversi√≥n a Number","text":"<p>Para convertir de forma expl√≠cita a Number se har√≠a de esta manera.</p> <pre><code>let str = \"98\";\nalert(typeof str); // string\n\nlet num = Number(str); // se convierte en 98\nlet conversionError = Number('754z') //Leer algo distinto a Number como la z, dar√° NaN\nlet emptyString = Number('') // Es cero\n</code></pre> <p>Dependiendo del tipo del valor a convertir tiene sus rarezas: </p> Valor de entrada Se convierte en‚Ä¶ Notas <code>undefined</code> <code>NaN</code> No es un n√∫mero v√°lido. <code>null</code> <code>0</code> Se trata como \"nada\" o vac√≠o num√©rico. <code>true</code> / <code>false</code> <code>1</code> / <code>0</code> Booleans binarios. <code>string</code> <code>0</code>, <code>Number</code> o <code>NaN</code> Se limpian los espacios antes de convertir.","path":["JavaScript"],"tags":[]},{"location":"java-script/#conversion-a-booleano","level":4,"title":"Conversi√≥n a Booleano","text":"<p>Los valores conocidos como falsy, que se explicar√°n a continuaci√≥n, se evaluan a false. Mientras el resto eval√∫a como true</p>","path":["JavaScript"],"tags":[]},{"location":"java-script/#truthy-falsy-values","level":2,"title":"Truthy &amp; Falsy Values","text":"<p>JS intenta convertir cualquier cosa a booleano si lo pones en un <code>if</code>.</p> <p>Los 5 valores Falsy (Se convierten a <code>false</code>):</p> <ol> <li><code>0</code></li> <li><code>''</code> (String vac√≠o)</li> <li><code>undefined</code></li> <li><code>null</code></li> <li><code>NaN</code> (Not a Number)</li> </ol> <p>Todo lo dem√°s es Truthy.</p> <p>‚ö†Ô∏è En JS, un array vac√≠o [] y objeto vac√≠o {} son true.</p>","path":["JavaScript"],"tags":[]},{"location":"java-script/#operadores","level":2,"title":"Operadores","text":"","path":["JavaScript"],"tags":[]},{"location":"java-script/#operadores-aritmeticos","level":3,"title":"Operadores Ar√≠tmeticos","text":"<p>Antes que nada es importante distinguir cuando un operador es unario y cuando binario. Si el operador solo tiene un operando, se considera unario.</p> <pre><code>const number = 5;\nconsole.log(-number) // Lo convierte a negativo, -5\nconsole.log(+'5') // Lo convierte a Number, 5\n</code></pre> <p>Los binarios operan como en la matem√°tica tradicional, y tenemos los siguientes:</p> Operador Precedencia Asociatividad Ejemplo <code>**</code> 13 Derecha a Izquierda ‚¨ÖÔ∏è <code>2 ** 3 ** 2</code> ‚ûî <code>512</code> <code>*</code> 12 Izquierda a Derecha ‚û°Ô∏è <code>2 * 3 * 2</code> ‚ûî <code>12</code> <code>/</code> 12 Izquierda a Derecha ‚û°Ô∏è <code>10 / 2 / 5</code> ‚ûî <code>1</code> <code>%</code> 12 Izquierda a Derecha ‚û°Ô∏è <code>10 % 3</code> ‚ûî <code>1</code> <code>+</code> 11 Izquierda a Derecha ‚û°Ô∏è <code>1 + 2</code> ‚ûî <code>3</code> <code>-</code> 11 Izquierda a Derecha ‚û°Ô∏è <code>5 - 2</code> ‚ûî <code>3</code> <p>Cabe destacar, que funcionan as√≠ cuando los dos operando son Numbers, sino se empezar√≠an a aplicar las reglas que hemos visto anteriormente de \"coercion\". Por ejemplo el operador \"+\", fuera del √°mbito ar√≠tmetico en JS tambi√©n sirve para concatenar strings.</p>","path":["JavaScript"],"tags":[]},{"location":"java-script/#operadores-logicos","level":3,"title":"Operadores L√≥gicos","text":"<ul> <li><code>and</code> -&gt; <code>&amp;&amp;</code></li> <li><code>or</code> -&gt; <code>||</code></li> <li><code>not</code> -&gt; <code>!</code></li> </ul>","path":["JavaScript"],"tags":[]},{"location":"java-script/#operador-nullish-coalescing","level":3,"title":"Operador Nullish Coalescing '??'","text":"<p>El operador <code>||</code> puede genear problemas cuando solo queremos evaluar si algo es undefined o null, ya que tambi√©n cuenta el <code>0</code> o <code>''</code> como false.</p> <p>El operador nullish arregla esto, ya que solo eval√∫a como falso, undefined y null.</p> <pre><code>const myMark = 0;\n\nmyMark || 'No se ha corregido' //En este caso si que tiene nota, tiene un 0, por lo que fallar√≠a.\nmyMark ?? 'No se ha corregido' // En este caso mostrar√≠a correctamente el 0 como nota.\n</code></pre>","path":["JavaScript"],"tags":[]},{"location":"java-script/#operador-ternario-y-typeof","level":3,"title":"Operador ternario y typeof","text":"<p><code>typeof</code> es un operador especial que sirve para saber el tipo de dato de un valor o variable.</p> <p><pre><code>const number = 5;\nconsole.log(typeof number) //Number\nconsole.log(typeof '7') //String\n</code></pre> El operador ternanrio sirve para expresar un condicional de una manera m√°s compacta.</p> <pre><code>const age = 24;\nconst isAdult = 24 &gt;= 18 ? 'Es mayor de edad' : 'Es menor de edad';\nconsole.log(isAdult); //Es mayor de edad\n</code></pre>","path":["JavaScript"],"tags":[]},{"location":"java-script/#precedence","level":3,"title":"Precedence","text":"<p>Todo los operadores se rigen a unas normas para establecer cuales se aplican antes. Esto lo podemos ver m√°s en profundidad. En la documentaci√≥n.</p> <p>El par√©ntesis tiene la precedencia m√°s alta, asi que lo podemos usar como lo har√≠amos en matem√°ticas, cuando sea necesario, o para aclarar el orden visual de las operaciones para las futuras personas que puedan leer el c√≥digo.</p>","path":["JavaScript"],"tags":[]},{"location":"java-script/#short-circuiting-y","level":2,"title":"Short Circuiting (&amp;&amp; y ||)","text":"<p>En JS, estos operadores no devuelven <code>true/false</code>, devuelven el valor.</p>","path":["JavaScript"],"tags":[]},{"location":"java-script/#or","level":3,"title":"OR (<code>||</code>)","text":"<p>Devuelve el primer valor TRUTHY que encuentre. Si todos son falsos, devuelve el √∫ltimo.</p> <ul> <li>Uso antiguo: Asignar valores por defecto.</li> </ul> <pre><code>// Si restaurant.guests es 0, undefined o null... guests1 ser√° 10.\nconst guests1 = restaurant.numGuests || 10;\n</code></pre> <ul> <li>‚ö†Ô∏è Bug: Si <code>numGuests</code> es <code>0</code> (un n√∫mero v√°lido de guests), JS lo toma como falsy y pone 10. Error l√≥gico grave. Para esto fue dise√±ado el operador nullish explicado anteriormente.</li> </ul>","path":["JavaScript"],"tags":[]},{"location":"java-script/#and","level":3,"title":"AND (<code>&amp;&amp;</code>)","text":"<p>Devuelve el primer valor FALSY. Si todos son verdaderos, devuelve el √∫ltimo.</p> <ul> <li>Uso: Reemplazar <code>if</code> simples.</li> </ul> <pre><code>// Si orderPizza existe, ejec√∫tala. Si no, no hagas nada.\nrestaurant.orderPizza &amp;&amp; restaurant.orderPizza('Mushrooms');\n</code></pre>","path":["JavaScript"],"tags":[]},{"location":"java-script/#equality-operators-vs","level":2,"title":"Equality Operators: <code>==</code> vs <code>===</code>","text":"<p>El <code>===</code> a diferencia de los dos iguales comprueba que el tipo de dato y el valor sean iguales, mientras que el otro solo se fija en el valor, no le importa que tipo de dato sea, porque realiza coerci√≥n.</p> <ul> <li><code>==</code> (Loose equality): Hace Coerci√≥n de tipo. <code>'18' == 18</code> es <code>true</code>. No es recomendable.</li> <li><code>===</code> (Strict equality): No hace coerci√≥n. <code>'18' === 18</code> es <code>false</code>. Es preferible usar este aunque haya que hacer conversiones expl√≠citas.</li> </ul> <pre><code>const num = '18';\nif (num === 18) console.log('Strict'); // False (String != Number)\nif (num == 18)  console.log('Loose');  // True (JS convierte string a numero)`\n</code></pre>","path":["JavaScript"],"tags":[]},{"location":"java-script/#condicionales-y-switch","level":2,"title":"Condicionales y Switch","text":"","path":["JavaScript"],"tags":[]},{"location":"java-script/#if-else","level":3,"title":"if - else","text":"<p>En JS por lo general el codigo que se ejecutar√° al evaluarse una condici√≥n va entre llaves, salvo que solo se quiera ejecutar una sentencia que en este caso se podr√≠an omitir las llaves. Pero por lo general se recomienda usar las llaves</p> <pre><code>const myMark = 7;\n\nif (myMark &gt;= 5) console.log('Aprobado'); // Sin llaves\n\nif (myMark &gt;= 5) {\n    console.log('Aprobado') // Con llaves (opcional)\n}\n\nif (myMark &gt;= 5) {\n    const result = 'Aprobado';\n    console.log(result); // Con llaves (obligario, por ser m√°s de una sentencia)\n}\n</code></pre> <p>La estructura general de los condicionales no cambian mucho con respecto a otros lenguajes.</p> <pre><code>const age = 25;\nif (age &gt; 18) {\n    console.log('Mayor de 18');\n} else if (age &lt; 18) {\n    console.log('Menor de 18');\n} else {\n    console.log('Tiene exactamente 18');\n}\n\n// Tambi√©n se podr√≠a expresar as√≠, porque en este caso solo es una stament por bloque.\n\nif (age &gt; 18) console.log('Mayor de 18');\nelse if (age &lt; 18) console.log('Menor de 18');\nelse console.log('Exactamente 18');\n</code></pre>","path":["JavaScript"],"tags":[]},{"location":"java-script/#switch","level":3,"title":"Switch","text":"<p>Cada vez se usa menos, pero es importante conocerlo.</p> <ul> <li>Usa comparaci√≥n estricta (<code>===</code>).</li> <li>¬°Necesita <code>break</code> al final de cada caso o ejecuta el siguiente!</li> </ul> <p>JavaScript</p> <p><code>const day = 'monday'; switch(day) {     case 'monday': // day === 'monday'         console.log('Plan course structure');         break; // ¬°Importante! case:     default:         console.log('Not a valid day'); }</code></p>","path":["JavaScript"],"tags":[]},{"location":"java-script/#agrupar-varios-case-fall-through","level":4,"title":"Agrupar varios <code>case</code> (Fall-through)","text":"<p>En JavaScript, si no pones la palabra <code>break</code>, el c√≥digo \"cae\" hacia abajo y ejecuta el siguiente caso. Esto se usa para agrupar l√≥gica.</p> <p>Escenario: Clasificar d√≠as en Laborales vs. Fin de semana.</p> <pre><code>const day = 'wednesday';\n\nswitch (day) {\n    case 'monday': // No hay break, sigue bajando\n    case 'tuesday':\n    case 'wednesday':\n    case 'thursday':\n    case 'friday':\n        console.log('üìÖ Es d√≠a laboral, a trabajar!');\n        // Aqu√≠ S√ç ponemos break para que pare y no siga bajando\n        break;\n\n    case 'saturday':\n    case 'sunday':\n        console.log('üéâ Es fin de semana, descansa.');\n        break;\n\n    default:\n        console.log('‚ùå Ese d√≠a no existe.');\n}\n</code></pre>","path":["JavaScript"],"tags":[]},{"location":"java-script/#usar-comparaciones-con-switchtrue","level":4,"title":"Usar comparaciones (<code>&gt;=</code>, <code>&lt;</code>, <code>&amp;&amp;</code>) con <code>switch(true)</code>","text":"<p>El <code>switch</code> est√°ndar de JS compara valores exactos (<code>===</code>). No puedes hacer <code>case age &gt; 18</code> directamente.</p> <p>Para lograr esto, usamos un \"Hack\" muy com√∫n: Hacemos el switch sobre el valor <code>true</code>. JS preguntar√°: \"¬øEs <code>true</code> igual a la condici√≥n de este caso?\".</p> <p>Escenario: Clasificar por rangos de edad.</p> <pre><code>const age = 25;\n\n// Truco: Hacemos switch sobre 'true'\nswitch (true) {\n    case age &gt;= 18 &amp;&amp; age &lt; 65:\n        console.log('üßë Adulto en edad laboral');\n        break;\n\n    case age &gt;= 65:\n        console.log('üë¥ Jubilado');\n        break;\n\n    case age &lt; 18 &amp;&amp; age &gt;= 0:\n        console.log('üë∂ Menor de edad');\n        break;\n\n    default:\n        console.log('üëª Edad no v√°lida');\n}\n</code></pre> <p>La mayor√≠a de veces es mejor usar un if-else que recurrir a un switch(true)</p>","path":["JavaScript"],"tags":[]},{"location":"java-script/#bucles","level":2,"title":"Bucles","text":"","path":["JavaScript"],"tags":[]},{"location":"java-script/#bucle-for","level":3,"title":"Bucle for","text":"","path":["JavaScript"],"tags":[]},{"location":"java-script/#tradicional","level":4,"title":"Tradicional","text":"<pre><code>for (begin; condition; step) {\n    // codigo\n}\n</code></pre> <p><pre><code>for (let i = 0; i &lt; 10; i++) {\n    console.log(i);\n}\n</code></pre> - Primero se inicializa una varible, con let porque cambiara en cada iteraci√≥n. - A continuaci√≥n se comprueba la condici√≥n si 0 &lt; 10. - Si es verdad se ejecuta el codigo definido dentro del bloque. - Despu√©s se le suma 1 y se pasa a la siguiente iteraci√≥n. - Esto continua en bucle, de ah√≠ su nombre, hasta que no se cumpla la condici√≥n.</p> <p>Curiosidad: No se suele usar, pero se pueden omitir partes del bucle. Ejemplo: for(;;){}</p>","path":["JavaScript"],"tags":[]},{"location":"java-script/#for-of","level":4,"title":"for of","text":"<pre><code>const animals = ['gato', 'perro', 'gallina']\nfor (const animal of animals) {\n    console.log(animal); // En este bucle se muestra cada elemento de la lista. Una similitud ser√≠a el for de Python\n}\n</code></pre>","path":["JavaScript"],"tags":[]},{"location":"java-script/#for-in","level":4,"title":"for in","text":"<p>El bucle <code>for...in</code> se utiliza para recorrer las propiedades (claves) de un objeto. En cada iteraci√≥n, devuelve el nombre de la clave, no el valor directamente.</p> <pre><code>for (let key in object) {\n  // c√≥digo a ejecutar\n}\n</code></pre>","path":["JavaScript"],"tags":[]},{"location":"java-script/#while","level":3,"title":"While","text":"","path":["JavaScript"],"tags":[]},{"location":"java-script/#while-comun","level":4,"title":"While com√∫n","text":"<p>Es el while de todo la vida, se suele usar cuando no sabes cuantas veces tendr√°s que iterar.</p> <pre><code>let tries = 0;\n\nwhile (tries &lt; 3) {\n    console.log(`${tries}`)\n    tries++;\n}\n\n// Tambi√©n se puede hacer. Pero suele ser peor pr√°ctica. No es recomendable, salv√≥ casos necesarios.\nwhile (true) {\n    if (tries === 3) {\n        break;\n    }\n    console.log(`${tries}`)\n    tries++;\n}\n</code></pre>","path":["JavaScript"],"tags":[]},{"location":"java-script/#do-while","level":4,"title":"Do While","text":"<p>Es similar al bucle <code>while</code>, pero con una diferencia crucial: garantiza que el bloque de c√≥digo se ejecute al menos una vez.</p> <p>Primero ejecuta el cuerpo del bucle y despu√©s eval√∫a la condici√≥n. Es ideal para validar datos de entrada (como un <code>prompt</code>), ya que necesitamos preguntar al usuario al menos una vez antes de decidir si volvemos a preguntar.</p> <pre><code>let number; // Definimos number fuera, porque si lo hacemos dentro de las llaves no ser√° accesible desde el exterior.\n\ndo {\n    number = Number(prompt('Introduce un numero del 1 al 10'));\n    // El bucle se repite SI el n√∫mero es menor a 1 O mayor a 10\n} while (number &lt; 0 || number &gt; 10);\n</code></pre>","path":["JavaScript"],"tags":[]},{"location":"java-script/#funciones","level":2,"title":"Funciones","text":"","path":["JavaScript"],"tags":[]},{"location":"java-script/#tipos-principales","level":3,"title":"Tipos principales","text":"","path":["JavaScript"],"tags":[]},{"location":"java-script/#function-declaration","level":4,"title":"Function Declaration","text":"<pre><code>function calcAge1(birthYear) {\n    return 2037 - birthYear;\n}\n</code></pre> <p>Caracter√≠stica Clave: Pueden ser llamadas antes de ser definidas en el c√≥digo gracias al Hoisting (elevaci√≥n). El motor de JS las lee antes de ejecutar nada.</p>","path":["JavaScript"],"tags":[]},{"location":"java-script/#function-expression","level":4,"title":"Function Expression","text":"<p>Guardamos una funci√≥n (an√≥nima) dentro de una variable.</p> <pre><code>const calcAge2 = function (birthYear) {\n    return 2037 - birthYear;\n}\n</code></pre> <p>Caracter√≠stica Clave: No tienen Hoisting. Te obligan a definir antes de usar (lo cual fomenta un c√≥digo m√°s ordenado). En JS, una funci√≥n es un valor, igual que un n√∫mero o un string.</p>","path":["JavaScript"],"tags":[]},{"location":"java-script/#arrow-function","level":4,"title":"Arrow Function","text":"<p>Sintaxis moderna, r√°pida y limpia para funciones.</p> <p><pre><code>const calcAge3 = (birthYear) =&gt; 2037 - birthYear;\n// En caso de tener solo un argumento no es obligatorio poner el par√©ntesis, pero se recomienda ponerlo siempre por uniformidad del c√≥digo.\n</code></pre> - Cuando la funci√≥n tiene una sola expresi√≥n, el valor se retorna de forma impl√≠cita.</p> <ul> <li>Si tiene un solo par√°metro, los par√©ntesis no son obligatorios, pero se recomienda usarlos por consistencia y legibilidad.</li> </ul> <pre><code>const calcAge3 = (birthYear) =&gt; {\n    const result = 2037 - birthYear;\n    return result;\n} \n</code></pre> <p>Cuando la funci√≥n tiene m√°s de una instrucci√≥n (statement), es obligatorio:</p> <ul> <li> <p>Usar llaves {}</p> </li> <li> <p>Usar return expl√≠cito</p> </li> </ul> <p>Diferencia Cr√≠tica: No tienen su propio <code>this</code>. Toman el <code>this</code> del padre (lexical <code>this</code>).</p>","path":["JavaScript"],"tags":[]},{"location":"java-script/#parametros-por-defecto","level":3,"title":"P√°rametros por defecto","text":"<ul> <li> <p>Evaluaci√≥n Din√°mica: En JS, los par√°metros por defecto se eval√∫an en tiempo de llamada, lo que permite usar par√°metros anteriores para calcular los siguientes.</p> <pre><code>const booking = function(flightNum, numPassengers = 1, price = 199 * numPassengers) {\n    // 'price' se calcula usando 'numPassengers' al vuelo\n};\n</code></pre> </li> <li> <p>Saltar argumentos: No puedes hacer <code>booking('LH123', , 200)</code>. Si quieres usar el default del medio, tienes que pasar expl√≠citamente <code>undefined</code>.</p> <ul> <li><code>booking('LH123', undefined, 200)</code> -&gt; <code>numPassengers</code> ser√° 1.</li> </ul> </li> </ul>","path":["JavaScript"],"tags":[]},{"location":"java-script/#argumentos-por-valor-vs-por-referencia","level":3,"title":"Argumentos por valor vs por referencia.","text":"<ol> <li> <p>Primitivos (Ej: Numbers, Strings): Se pasan por copia. Si la funci√≥n cambia el valor, la variable original fuera NO cambia.</p> </li> <li> <p>Objetos (Arrays, Objects): Se pasa la referencia (direcci√≥n de memoria). Si modificas una propiedad del objeto dentro de la funci√≥n, el objeto original fuera de la funci√≥n muta.</p> </li> </ol>","path":["JavaScript"],"tags":[]},{"location":"java-script/#pure-functions-funciones-puras","level":3,"title":"Pure Functions (Funciones Puras)","text":"<p>Aunque no es un concepto √∫nico del lenguaje, es importante tener en cuenta la importancia de mantener nustras funciones \"puras\". Con el fin de hacer que el c√≥digo sea predecible y f√°cil de testear (debug).</p> <p>¬øQu√© quiere decir esto?</p> <p>Una funci√≥n que cumpla estrictamente dos reglas:</p> <ul> <li> <p>Misma entrada = Misma salida: Si le pasas los mismos argumentos (ej. 2 + 2), siempre debe devolver el mismo resultado (4), sin importar cu√°ntas veces o cu√°ndo la llames.</p> </li> <li> <p>Sin \"Side Effects\" (Efectos secundarios): La funci√≥n no debe modificar nada fuera de su propio cuerpo (variables globales, estado de la aplicaci√≥n, el DOM, etc.).</p> </li> </ul> <pre><code>const msg = 'Hola';\n\nfunction greeting(name) {\n    return `${msg}, ${name}`;\n}\n</code></pre> <p>Ejemplo de Impureza: Si una funci√≥n greeting(name) usa una variable externa msg = 'Hola' para crear el saludo, es impura. ¬øPor qu√©? Porque si alguien cambia la variable externa msg a \"Adi√≥s\", la funci√≥n devolver√° algo diferente para el mismo input nombre.</p>","path":["JavaScript"],"tags":[]},{"location":"java-script/#first-class-vs-higher-order-functions","level":3,"title":"First-Class vs Higher-Order Functions","text":"<p>JavaScript trata a las funciones como First-Class Citizens (Ciudadanos de primera clase). Significa que las funciones son valores, igual que un n√∫mero <code>5</code> o un string <code>'hola'</code>.</p> <p>A. Higher-Order Functions (Funciones de Orden Superior)</p> <p>Es cualquier funci√≥n que cumple al menos una de estas dos condiciones:</p> <ol> <li>Recibe una funci√≥n como argumento (Callback).</li> <li>Retorna una nueva funci√≥n.</li> </ol> <p>Concepto callback: Una funci√≥n que se pasa como argumento a otra funci√≥n para ser ejecutada (\"llamada de vuelta\") m√°s tarde dentro de esa funci√≥n externa.</p> <p>B. El patr√≥n Callback (Abstracci√≥n)</p> <pre><code>// HOF (Recibe la funci√≥n)\nconst transformador = function(str, fn) {\n    console.log(`Transformando: ${str}`);\n    return fn(str); // Ejecuta la funci√≥n que le pasaron\n}\n\n// Callbacks (Herramientas)\nconst upper = str =&gt; str.toUpperCase();\nconst oneWord = str =&gt; str.replace(/ /g, '').toLowerCase();\n\ntransformador('JavaScript es genial', upper);\ntransformador('JavaScript es genial', oneWord);\n</code></pre> <p>Por qu√© lo hacemos: Abstracci√≥n. transformador no se preocupa de c√≥mo se transforma el texto, solo delega esa tarea.</p>","path":["JavaScript"],"tags":[]},{"location":"java-script/#iife-immediately-invoked-function-expressions","level":3,"title":"IIFE (Immediately Invoked Function Expressions)","text":"<p>Un patr√≥n antiguo pero que ver√°s en c√≥digo legacy. Sirve para ejecutar una funci√≥n una √∫nica vez y crear un scope privado (antes de que existieran <code>let</code> y <code>const</code>).</p> <pre><code>(function() {\n    console.log('Esto nunca se ejecutar√° de nuevo');\n    const isPrivate = 23;\n})();\n</code></pre> <ul> <li>Hoy en d√≠a: Simplemente usamos un bloque <code>{ const isPrivate = 23; }</code> para privacidad.</li> </ul>","path":["JavaScript"],"tags":[]},{"location":"java-script/#recursion","level":3,"title":"Recursion","text":"<p>El cl√°sico. Calcular el factorial de un n√∫mero (ej. <code>3! = 3 * 2 * 1</code>).</p> <pre><code>function factorial(n) {\n    // 1. Caso Base (El freno de emergencia)\n    // Si no ponemos esto, la Call Stack explota (Stack Overflow)\n    if (n === 0) {\n        return 1;\n    }\n\n    // 2. Llamada Recursiva\n    // Se pausa este contexto y se crea uno nuevo encima\n    return n * factorial(n - 1);\n}\n\nconsole.log(factorial(3)); // Resultado: 6\n</code></pre> <p>¬øQu√© pasa en el Motor (Call Stack)?</p> <p>Imagina la pila de llamadas creciendo y luego bajando.</p> <p>Fase de Apilado (Ejecuci√≥n):</p> <ol> <li> <p>GEC: Llama a factorial(3).</p> </li> <li> <p>FEC factorial(3): n=3. ¬øEs 0? No. Retorna 3 * ¬ø...?.</p> <p>Pausa y llama a factorial(2).</p> </li> <li> <p>FEC factorial(2): n=2. ¬øEs 0? No. Retorna 2 * ¬ø...?.</p> <p>Pausa y llama a factorial(1).</p> </li> <li> <p>FEC factorial(1): n=1. ¬øEs 0? No. Retorna 1 * ¬ø...?.</p> <p>Pausa y llama a factorial(0).</p> </li> <li> <p>FEC factorial(0): n=0. ¬°CASO BASE! Retorna 1.</p> </li> </ol> <p>Fase de Desapilado (Resoluci√≥n):</p> <ul> <li> <p>factorial(0) retorna 1 y sale del stack.</p> </li> <li> <p>factorial(1) recibe el 1. Calcula 1 * 1 = 1. Sale del stack.</p> </li> <li> <p>factorial(2) recibe el 1. Calcula 2 * 1 = 2. Sale del stack.</p> </li> <li> <p>factorial(3) recibe el 2. Calcula 3 * 2 = 6. Sale del stack.</p> </li> <li> <p>GEC recibe 6 e imprime.</p> </li> </ul> <p>El significado de GEC Y FEC se explica con detalle en los fundamentos te√≥ricos</p>","path":["JavaScript"],"tags":[]},{"location":"java-script/#objetos","level":2,"title":"Objetos","text":"<p>A diferencia de los datos \"primitivos\" (que solo guardan un valor √∫nico), los objetos permiten almacenar colecciones de datos y entidades m√°s complejas. Son fundamentales en JavaScript.</p>","path":["JavaScript"],"tags":[]},{"location":"java-script/#conceptos-basicos","level":2,"title":"Conceptos B√°sicos","text":"<p>Imagina un objeto como un gabinete de archivos:</p> <p>Cada dato se guarda en un \"archivo\" identificado por una clave (nombre).</p> <p>Dentro del archivo est√° el valor.</p> <p>Creaci√≥n: Existen dos sintaxis, aunque la de \"objeto literal\" es la m√°s com√∫n:</p> <pre><code>let user = new Object(); // Constructor de objetos (menos com√∫n)\nlet user = {};           // Objeto literal (est√°ndar)\n</code></pre> <p>Estructura: Se definen mediante pares clave: valor.</p> <p><pre><code>let user = {\n  name: \"John\", // Clave: \"name\", Valor: \"John\"\n  age: 30       // Clave: \"age\", Valor: 30\n};\n</code></pre> Claves: Son siempre strings o s√≠mbolos. Si usas otro tipo, se convierte autom√°ticamente a string.</p> <p>Valores: Pueden ser cualquier tipo de dato (boolean, n√∫mero, otro objeto, etc.).</p>","path":["JavaScript"],"tags":[]},{"location":"java-script/#dot-notation-vs-bracket-notation","level":3,"title":"Dot Notation vs. Bracket Notation","text":"<p>Se puede acceder a las propiedades de los objetos de dos formas:</p> <ol> <li>Dot Notation (<code>objeto.propiedad</code>):<ul> <li>M√°s limpio y f√°cil de leer.</li> <li>Solo funciona si conoces el nombre exacto de la propiedad al escribir el c√≥digo.</li> </ul> </li> <li>Bracket Notation (<code>objeto['propiedad']</code>):<ul> <li>Permite usar expresiones. Puedes poner una variable dentro de los corchetes.</li> <li>Ejemplo: <code>objeto['first' + namePart]</code></li> </ul> </li> </ol>","path":["JavaScript"],"tags":[]},{"location":"java-script/#posibles-errores","level":4,"title":"Posibles Errores","text":"<pre><code>const jonas = {\n    firstName: 'Jonas',\n    job: 'Teacher',\n    age: 30\n};\n</code></pre> <p>// Bucle cl√°sico para objetos  <pre><code>for (const key in jonas) {\n    // 'key' es una variable que va cambiando: 'firstName', 'job', 'age'...\n\n    console.log(jonas.key);   // ‚ùå ERROR (Undefined)\n    console.log(jonas[key]);  // ‚úÖ CORRECTO\n}\n</code></pre></p> <p>El problema es c√≥mo el motor de JavaScript \"lee\" (parsea) tu c√≥digo.</p> <p>A. Dot Notation (<code>jonas.key</code>) = Literal</p> <p>Cuando el motor ve un punto, apaga su cerebro evaluador. Interpreta lo que viene despu√©s como un String Literal.</p> <ul> <li>Instrucci√≥n: \"Busca dentro del objeto <code>jonas</code> una propiedad que se llame, LITERALMENTE, 'key'\".</li> <li>Resultado: <code>undefined</code> (porque <code>jonas</code> no tiene ninguna propiedad llamada \"key\", tiene \"firstName\", \"job\", etc.).</li> </ul> <p>B. Bracket Notation (<code>jonas[key]</code>) = Expresi√≥n</p> <p>Cuando el motor ve corchetes, sabe que tiene que evaluar una expresi√≥n primero.</p> <ol> <li>Instrucci√≥n: \"¬øQu√© hay dentro de los corchetes? Ah, una variable llamada <code>key</code>\".</li> <li>Evaluaci√≥n: \"¬øCu√°nto vale <code>key</code> ahora mismo? Vale 'firstName'\".</li> <li>Ejecuci√≥n final: \"Busca dentro de <code>jonas</code> la propiedad 'firstName'\".</li> <li>Resultado: <code>'Jonas'</code> (Correcto).</li> </ol>","path":["JavaScript"],"tags":[]},{"location":"java-script/#arrays","level":2,"title":"Arrays","text":"<p>Los objetos sirven para almacenar colecciones con claves, pero a menudo necesitamos una colecci√≥n ordenada (una lista), donde tenemos un primero, un segundo, un tercero, etc. Para eso existen los Arrays.</p> <pre><code>// Dos sintaxis para crear un array vac√≠o\nlet arr = new Array();\nlet arr = []; // ‚úÖ La m√°s com√∫n\n\nlet fruits = [\"Manzana\", \"Naranja\", \"Ciruela\"];\n\n// Acceso por √≠ndice (empieza en 0)\nalert( fruits[0] ); // Manzana\n\n// Reemplazar o agregar\nfruits[2] = \"Pera\"; // Reemplaza Ciruela\nfruits[3] = \"Lim√≥n\"; // Agrega nuevo\n</code></pre> <p>Nota: Un array puede almacenar elementos de cualquier tipo: strings, n√∫meros, booleanos, objetos e incluso otros arrays o funciones, todo mezclado en la misma lista.</p>","path":["JavaScript"],"tags":[]},{"location":"java-script/#arrays-multidimensionales-matrices","level":3,"title":"Arrays Multidimensionales (Matrices)","text":"<p>Los arrays pueden contener otros arrays.</p> <pre><code>let matrix = [\n  [1, 2, 3],\n  [4, 5, 6],\n  [7, 8, 9]\n];\n\nalert( matrix[1][1] );\n</code></pre>","path":["JavaScript"],"tags":[]},{"location":"java-script/#destructuring","level":2,"title":"Destructuring","text":"<p>Es la forma de \"desempaquetar\" valores de Arrays u Objetos en variables distintas.</p> <ul> <li>Arrays</li> </ul> <pre><code>const arr = [2, 3, 4];\nconst [x, y, z] = arr; // x=2, y=3, z=4\n\n// Saltar elementos\nconst [first, , third] = arr; // first=2, third=4`\n\n// Intercambio de variables\nlet jugador1 = \"Mando\";\nlet jugador2 = \"Teclado\";\n\n// Intercambiamos los valores en una sola l√≠nea\n[jugador1, jugador2] = [jugador2, jugador1];\n\nconsole.log(jugador1); // \"Teclado\"\nconsole.log(jugador2); // \"Mando\"\n</code></pre> <ul> <li>Objetos</li> </ul> <pre><code>const usuario = {\n  id: 42,\n  nombre: \"Elena\",\n  email: \"elena@code.com\",\n  pais: \"Espa√±a\",\n  premium: true\n};\n\n// --- SIN Desestructuraci√≥n (La forma antigua y repetitiva) ---\nconst nombre = usuario.nombre;\nconst email = usuario.email;\nconst premium = usuario.premium;\n\n// --- CON Desestructuraci√≥n (La forma moderna) ---\n// Le decimos a JS: \"Del objeto usuario, s√°came las propiedades nombre, email y premium\"\nconst { nombre, email, premium } = usuario;\n</code></pre>","path":["JavaScript"],"tags":[]},{"location":"java-script/#valores-por-defecto","level":3,"title":"Valores por Defecto","text":"<p>El problema: Imagina que esperas recibir 3 datos de una API, pero solo llegan 2. En JS normal, la tercera variable ser√≠a <code>undefined</code>. Eso puede romper c√°lculos matem√°ticos (<code>undefined + 5 = NaN</code>).</p> <p>La Soluci√≥n: Puedes asignar un valor de respaldo (\"fallback\") en la propia declaraci√≥n.</p> <pre><code>// Simulamos una respuesta de API incompleta\nconst apiResponse = [10, 20];\n\n// Sin defaults: r ser√≠a undefined\n// Con defaults:\nconst [p, q, r = 1] = apiResponse;\n\nconsole.log(p, q, r); \n// Output: 10, 20, 1 (¬°Salvado!)`\n</code></pre> <p>Esto es vital cuando lees datos externos que no controlas. Siempre asume que el dato puede no venir.</p> <p>En el caso de los objetos</p> <p>Sintaxis:</p> <p>propiedadOriginal: nuevoNombreVariable = valorPorDefecto</p> <pre><code>const restaurant = {\n  name: 'Pizza Hut',\n  // menu: no existe en este objeto\n};\n\n// Extracci√≥n cl√°sica vs Desestructuraci√≥n\nconst {\n  name: restaurantName,  // 1. Toman 'name', lo guardan en 'restaurantName'\n  menu: restaurantMenu = [] // 2. 'menu' no existe, as√≠ que usa []\n} = restaurant;\n\nconsole.log(restaurantName); // 'Pizza Hut'\nconsole.log(restaurantMenu); // [] (Array vac√≠o, ¬°salvados de undefined!)\n</code></pre>","path":["JavaScript"],"tags":[]},{"location":"java-script/#destructuring-anidado","level":3,"title":"Destructuring Anidado","text":"<p>A veces recibes un array dentro de otro array. Para sacarlo, tienes que mimetizar la estructura original.</p> <pre><code>const nested = [2, 4, [5, 6]];\n\n// Queremos el 2 (primer nivel) y el 6 (segundo nivel)\n// F√≠jate c√≥mo \"dibujamos\" la estructura dentro del const\nconst [i, , [, k]] = nested; \n\nconsole.log(i, k); // 2, 6`\n</code></pre> <ul> <li>An√°lisis:<ul> <li><code>i</code> toma el <code>2</code>.</li> <li>El primer espacio vac√≠o <code>,</code> salta el <code>4</code>.</li> <li><code>[, k]</code> entra al array hijo <code>[5, 6]</code>.</li> <li>La coma dentro del corchete salta el <code>5</code>.</li> <li><code>k</code> toma el <code>6</code>.</li> </ul> </li> </ul>","path":["JavaScript"],"tags":[]},{"location":"java-script/#desestructuracion-anidada-en-objetos","level":4,"title":"Desestructuraci√≥n Anidada en Objetos","text":"<p>Los objetos JSON suelen tener muchas capas de profundidad. Para sacar un dato profundo, debes imitar la estructura del objeto dentro de las llaves de desestructuraci√≥n.</p> <pre><code>const restaurant = {\n  openingHours: {\n    fri: { open: 11, close: 23 }\n  }\n};\n\n// Queremos sacar 'open' y 'close' directamente\nconst {\n  openingHours: {       // Entramos al primer nivel\n    fri: {              // Entramos al segundo nivel\n       open, close      // Extraemos las variables finales\n    }\n  }\n} = restaurant;\n\nconsole.log(open, close); // 11, 23\n</code></pre> <p>Ojo: En este ejemplo, las variables openingHours y fri no se crean. Solo sirven de \"camino\" para llegar a open y close.</p>","path":["JavaScript"],"tags":[]},{"location":"java-script/#mutacion-de-variables-la-trampa-de-los-parentesis","level":3,"title":"Mutaci√≥n de Variables (La Trampa de los Par√©ntesis)","text":"<p>A veces ya tienes variables creadas y quieres actualizar su valor con datos de un objeto. Aqu√≠ JavaScript se confunde.</p> <p>El problema: Si una l√≠nea empieza con {, JavaScript piensa que es un bloque de c√≥digo (como un if o un bucle), no un objeto.</p> <p>La soluci√≥n: Envolver toda la expresi√≥n en par√©ntesis ().</p> <pre><code>let a = 111;\nlet b = 999;\nconst obj = { a: 23, b: 7, c: 14 };\n\n// { a, b } = obj;  &lt;-- ‚ùå Error de sintaxis\n\n({ a, b } = obj); // &lt;-- ‚úÖ Correcto: Los par√©ntesis indican que es una expresi√≥n\n\nconsole.log(a, b); // 23, 7\n</code></pre>","path":["JavaScript"],"tags":[]},{"location":"java-script/#los-operadores-spread-y-rest","level":2,"title":"Los Operadores <code>...</code> (Spread y Rest)","text":"<p>El mismo s√≠mbolo <code>...</code> tiene dos efectos totalmente opuestos dependiendo de d√≥nde lo coloques respecto al signo igual (<code>=</code>).</p> S√≠mbolo Posici√≥n respecto a <code>=</code> Nombre Acci√≥n Analog√≠a <code>...</code> A la DERECHA del <code>=</code> Spread Desempaquetar Volcar una caja de juguetes al suelo <code>...</code> A la IZQUIERDA del <code>=</code> Rest Empaquetar Recoger los juguetes del suelo y meterlos en una bolsa","path":["JavaScript"],"tags":[]},{"location":"java-script/#spread-operator","level":3,"title":"Spread Operator","text":"<p>Posici√≥n: A la derecha (= ...) o en argumentos de funci√≥n. Misi√≥n: Sacar elementos de una colecci√≥n (Array/String/Objeto) y ponerlos sueltos en un nuevo contexto.</p> <ul> <li> <p>A. En Arrays (Inmutabilidad y Copia)</p> <p>En algunos frameworks modernos puede ser de mucha utilidad conocer est√° t√©cnica.</p> <pre><code>const menu = ['Pizza', 'Pasta'];\n\n// ‚ùå Muta el original\n// menu.push('Risotto');\n\n// ‚úÖ Crea uno nuevo\nconst newMenu = [...menu, 'Risotto']; \n// Resultado: ['Pizza', 'Pasta', 'Risotto']\n</code></pre> <p>Advertencia (Shallow Copy): El Spread hace una copia superficial. Si tu array tiene otros arrays dentro ([[1], [2]]), solo se copian las referencias de los hijos. Si modificas el hijo en la copia, cambias el original.</p> </li> <li> <p>B. En Funciones (Pasar argumentos)</p> <p>Si tienes los ingredientes en una lista pero la funci√≥n los pide por separado.</p> <p><pre><code>const ingredients = ['Setas', 'Queso'];\nconst cocinar = (ing1, ing2) =&gt; console.log(`Cocinado con ${ing1} y ${ing2}`);\n\n// El spread \"saca\" los items del array y los pasa como argumentos sueltos\ncocinar(...ingredients);\n</code></pre> - C. En Objetos (El uso m√°s potente) üåü</p> <p>Fundamental para actualizar propiedades sin mutar el objeto original.</p> <p>El Patr√≥n \"Override\" (Sobrescritura): El orden importa. Las propiedades que pongas despu√©s del ...spread sobrescriben a las anteriores.</p> <pre><code>const tarea = { id: 1, texto: 'Estudiar JS', completado: false };\n\n// Queremos cambiar 'completado' a true, manteniendo el resto igual\nconst tareaActualizada = {\n    ...tarea,           // 1. Copia todo (id, texto, completado: false)\n    completado: true    // 2. Sobrescribe 'completado'\n};\n\n// ‚ùå Si lo haces al rev√©s ({ completado: true, ...tarea }), gana el valor antiguo.\n</code></pre> </li> </ul>","path":["JavaScript"],"tags":[]},{"location":"java-script/#rest-pattern","level":3,"title":"Rest Pattern","text":"<p>Posici√≥n: A la izquierda (const ... =) o recibiendo argumentos en funci√≥n. Misi√≥n: Agrupar los elementos \"sobrantes\" en un array o un objeto nuevo.</p> <ul> <li> <p>A. En Desestructuraci√≥n de Arrays</p> <p>Recoge el \"resto\" de elementos que no has sacado expl√≠citamente.</p> <pre><code>const [primero, segundo, ...resto] = [10, 20, 30, 40, 50];\n\nconsole.log(primero); // 10\nconsole.log(resto);   // [30, 40, 50] (Array con lo que sobr√≥)\n</code></pre> </li> <li> <p>B. En Objetos: El \"Borrado Inmutable\" üåü</p> <p>C√≥mo eliminar una propiedad sin usar delete (que es lento y muta).</p> <p><pre><code>const user = {\n    password: \"12345_secret\",\n    name: \"Juan\",\n    email: \"juan@mail.com\"\n};\n\n// Sacamos 'password' a una variable aparte, y guardamos TODO LO DEM√ÅS en 'userSeguro'\nconst { password, ...userSeguro } = user;\n\nconsole.log(userSeguro); \n// { name: \"Juan\", email: \"juan@mail.com\" } -&gt; ¬°Objeto limpio!\n</code></pre> - C. En Funciones (Argumentos infinitos)</p> <p>Permite que una funci√≥n reciba cualquier cantidad de par√°metros.</p> <pre><code>// Recibe todos los argumentos y los mete en un array real llamado 'numeros'\nconst sumarTodo = function(...numeros) {\n    let total = 0;\n    for (let n of numeros) total += n;\n    return total;\n};\nsumarTodo(1, 2, 5, 10); // Funciona con cualquier cantidad\n</code></pre> <p>Regla de Oro: El Rest element (...resto) siempre debe ser el √∫ltimo en la lista de argumentos o desestructuraci√≥n. JS necesita saber que ah√≠ es donde \"termina\" y recoge todo lo que sobra.</p> </li> </ul> <p>Diferencia T√©cnica Cr√≠tica</p> <p>Arrays: Son iterables. Puedes usar ... donde quieras.</p> <p>Objetos: NO son iterables.</p> <p>‚úÖ { ...obj }: S√≠ puedes esparcir un objeto dentro de otro objeto.</p> <p>‚ùå [ ...obj ]: No puedes esparcir un objeto dentro de un array (Error: object is not iterable).</p>","path":["JavaScript"],"tags":[]},{"location":"java-script/#mapas-y-sets","level":2,"title":"Mapas y Sets","text":"","path":["JavaScript"],"tags":[]},{"location":"java-script/#map","level":3,"title":"Map","text":"<p>Un Map es una colecci√≥n de pares clave-valor.</p> <p>A primera vista parece un Objeto ({}), pero tiene diferencias fundamentales que lo hacen superior para guardar diccionarios de datos o cach√©s.</p> <p>Diferencias Clave con los Objetos:</p> <ul> <li> <p>Claves de cualquier tipo: En un Objeto, las claves solo pueden ser Strings o Symbols. En un Map, la clave puede ser lo que quieras: un n√∫mero, un booleano, o incluso otro objeto o una funci√≥n.</p> </li> <li> <p>Orden garantizado: El Map recuerda el orden original de inserci√≥n. Los objetos no siempre garantizan esto.</p> </li> <li> <p>Tama√±o directo: Tienen una propiedad .size. (En un objeto tienes que contar las claves manualmente).</p> </li> </ul> <pre><code>// Crear un Map\nconst mapObject = new Map();\n\n// 1. set(clave, valor): Guardar datos\nmapObject.set('nombre', 'Eduardo');\nmapObject.set(1, 'numero uno'); // Clave num√©rica\nmapObject.set(true, 'booleano'); // Clave booleana\n\nconst objClave = { id: 1 };\nmapObject.set(objClave, 'Objeto como clave'); // ¬°Esto es imposible en un objeto normal!\n\n// 2. get(clave): Obtener datos\nconsole.log(mapObject.get(1)); // \"numero uno\"\nconsole.log(mapObject.get(objClave)); // \"Objeto como clave\"\n\n// 3. has(clave): ¬øExiste?\nconsole.log(mapObject.has('nombre')); // true\n\n// 4. delete(clave) y clear()\nmapObject.delete(true); // Borra uno\nmapObject.clear();      // Borra todo\n\n// 5. Tama√±o\nconsole.log(mapObject.size);\n</code></pre>","path":["JavaScript"],"tags":[]},{"location":"java-script/#set","level":3,"title":"Set","text":"<p>Un Set es una estructura de datos que almacena una colecci√≥n de valores donde cada valor puede aparecer una sola vez. Si intentas meter un duplicado, el Set simplemente lo ignora.</p> <p>A diferencia de un Array, no tiene √≠ndices (no existe set[0]).</p> <p>‚ö° El Secreto de su Velocidad: El Hashing La gran diferencia t√©cnica con un Array es c√≥mo guarda los datos internamente. Los Sets utilizan una Tabla Hash.</p> <ol> <li> <p>¬øQu√© es el Hash? Cuando guardas un dato (ej. \"Hola\"), el motor de JS aplica una f√≥rmula matem√°tica para generar un c√≥digo √∫nico (hash) que sirve como direcci√≥n de memoria directa.</p> </li> <li> <p>La Diferencia:</p> <ul> <li> <p>En un Array (includes): El motor tiene que recorrer la lista elemento por elemento hasta encontrarlo (Lento si hay millones de datos).</p> </li> <li> <p>En un Set (has): El motor calcula el hash de lo que buscas y va directamente a esa direcci√≥n de memoria. No \"busca\", simplemente \"va\".</p> </li> </ul> </li> </ol> <p>Resumen: Gracias al hashing, comprobar si un dato existe en un Set es casi instant√°neo (Complejidad O(1)), sin importar si tienes 10 datos o 1 mill√≥n.</p> <pre><code>const guests = new Set();\n\n// 1. Agregar (add)\nguests.add(\"Pepe\");\nguests.add(\"Ana\");\nguests.add(\"Pepe\"); // IGNORADO: El hash de \"Pepe\" ya est√° ocupado.\n\nconsole.log(guests); // Set(2) { 'Pepe', 'Ana' }\n\n// 2. Comprobar existencia (has) - Esto usa el Hash\nif (guests.has(\"Ana\")) {\n    console.log(\"Ana est√° en la lista\");\n}\n\n// 3. Truco: Eliminar duplicados de un Array\nconst numeros = [1, 2, 2, 3];\nconst unicos = [...new Set(numeros)]; // [1, 2, 3]\n</code></pre>","path":["JavaScript"],"tags":[]},{"location":"java-script/#manejo-de-errores","level":2,"title":"Manejo de Errores","text":"<p>1. Parsing Error vs. Runtime Error</p> <ul> <li> <p>Parsing Error (Errores de An√°lisis): Ocurren antes de que el c√≥digo empiece a ejecutarse. El motor analiza la gram√°tica del script; si encuentra un fallo de sintaxis (ej. falta un par√©ntesis), detiene el proceso y no ejecuta nada.</p> </li> <li> <p>Runtime Error (Excepciones): El c√≥digo es gramaticalmente correcto y la ejecuci√≥n comienza, pero ocurre algo inesperado durante el proceso (ej. intentar leer una propiedad de <code>null</code>). Estos son los errores que se pueden manejar mediante c√≥digo.</p> </li> </ul> <p>2. Flujo de Control en Excepciones</p> <ul> <li> <p>Cuando el motor detecta una excepci√≥n dentro de un bloque <code>try</code>, suspende inmediatamente la ejecuci√≥n en esa l√≠nea.</p> </li> <li> <p>El resto del c√≥digo dentro del <code>try</code> se ignora.</p> </li> <li> <p>El motor busca el bloque <code>catch</code> m√°s cercano en la pila de llamadas (Call Stack) y transfiere el control (\"salta\") directamente all√≠.</p> </li> </ul> <p>3. El Objeto Error y Stack Trace</p> <ul> <li> <p>Al generarse un error, JS crea un objeto con propiedades clave: <code>name</code> y <code>message</code>.</p> </li> <li> <p><code>stack</code> (Pila de llamadas): Contiene una \"foto\" instant√°nea del Call Stack en el momento del error. Muestra la jerarqu√≠a de funciones activas, permitiendo rastrear el origen del problema (archivo, l√≠nea, funci√≥n).</p> </li> </ul> <p>1. Tipos de Errores Nativos</p> <p>Constructores integrados en el lenguaje:</p> <ul> <li> <p><code>ReferenceError</code>: Intento de uso de una variable no declarada o fuera de alcance.</p> </li> <li> <p><code>TypeError</code>: Operaci√≥n no v√°lida para el tipo de dato (ej. ejecutar una variable que no es funci√≥n, acceder a propiedades de <code>undefined</code>).</p> </li> <li> <p><code>SyntaxError</code>: C√≥digo mal escrito.</p> </li> <li> <p><code>RangeError</code>: Valor num√©rico fuera del rango permitido.</p> </li> </ul> <p>2. Estructura <code>try...catch...finally</code></p> <ul> <li> <p><code>try</code>: Envuelve el c√≥digo susceptible a fallar.</p> </li> <li> <p><code>catch(err)</code>: Se ejecuta solo si ocurre un error. Recibe el objeto del error como argumento.</p> </li> <li> <p><code>finally</code>: Se ejecuta SIEMPRE, ocurra un error o no.</p> <ul> <li>Uso principal: Limpieza de recursos (cerrar conexiones, liberar memoria, resetear UI).</li> </ul> </li> </ul> <p>3. Throw vs. Rethrow</p> <ul> <li> <p><code>throw</code>: Lanza una excepci√≥n manualmente para detener la ejecuci√≥n cuando no se cumple una regla l√≥gica.</p> </li> <li> <p><code>rethrow</code> (Relanzar): Capturar un error en un nivel bajo, procesarlo (ej. guardar un log) y volver a lanzarlo (<code>throw err</code>) para que sea manejado por una capa superior de la aplicaci√≥n.</p> </li> </ul> <p>Estructura B√°sica e Inspecci√≥n</p> <pre><code>try {\n    console.log(\"Iniciando proceso...\");\n    funcionInexistente(); // Lanza ReferenceError\n    console.log(\"Esto nunca se imprime\"); \n\n} catch (error) {\n    console.error(\"¬°Error capturado!\");\n    console.log(\"Tipo:\", error.name);     // ReferenceError\n    console.log(\"Mensaje:\", error.message); // funcionInexistente is not defined\n    // console.log(error.stack); // Traza completa para debugging\n}\n</code></pre> <p>Throw (Error Manual) y Finally</p> <pre><code>function procesarPago(monto) {\n    try {\n        if (monto &lt;= 0) {\n            // Detenemos la ejecuci√≥n manualmente\n            throw new Error(\"El monto debe ser positivo\");\n        }\n        console.log(\"Procesando pago...\");\n    } catch (err) {\n        console.log(\"Fallo en el pago:\", err.message);\n    } finally {\n        // Se ejecuta siempre, haya error o no\n        console.log(\"Operaci√≥n finalizada (Limpieza de sistema).\");\n    }\n}\n\nprocesarPago(-10);\n</code></pre> <p>Custom Errors (Versi√≥n Moderna: Clases)</p> <p>Hoy en d√≠a se utiliza la palabra clave <code>class</code> y <code>extends</code> para heredar todas las funcionalidades del objeto nativo <code>Error</code> (como el stack trace autom√°tico).</p> <p>Ventajas Te√≥ricas:</p> <ul> <li> <p>Herencia correcta: Al usar <code>extends Error</code>, JS conecta autom√°ticamente la cadena de prototipos.</p> </li> <li> <p><code>super(message)</code>: Llama al constructor interno de <code>Error</code>, que se encarga de asignar la propiedad <code>.message</code> correctamente.</p> </li> <li> <p>Identificaci√≥n: Permite usar <code>instanceof</code> para identificar el tipo de error de forma precisa.</p> </li> </ul> <pre><code>// Definici√≥n moderna usando Clases\nclass ValidationError extends Error {\n    constructor(message) {\n        // 1. Llamamos al constructor padre (Error) para que configure el mensaje\n        super(message); \n\n        // 2. Asignamos el nombre de nuestra clase\n        this.name = \"ValidationError\"; \n    }\n}\n\n// Uso\ntry {\n    const usuario = \"\";\n    if (!usuario) {\n        throw new ValidationError(\"El usuario no puede estar vac√≠o\");\n    }\n} catch (err) {\n    // Podemos comprobar exactamente qu√© tipo de error es\n    if (err instanceof ValidationError) {\n        console.log(\"Error de validaci√≥n detectado:\", err.message);\n    } else {\n        console.log(\"Error desconocido:\", err);\n    }\n}\n</code></pre>","path":["JavaScript"],"tags":[]},{"location":"java-script/async/","level":1,"title":"Asincron√≠a en JavaScript","text":"<p>JavaScript es un lenguaje Single-Threaded (un solo hilo). Esto significa que solo puede hacer una cosa a la vez. Sin embargo, la asincron√≠a permite que tareas pesadas (como pedir datos a un servidor o esperar un temporizador) se ejecuten en \"segundo plano\" sin bloquear el hilo principal.</p> <p>Para entender la asincron√≠a, hay que visualizar las piezas que componen el entorno de ejecuci√≥n (como el navegador):</p> <ol> <li>Call Stack (Pila de Ejecuci√≥n): Es donde se ejecuta el c√≥digo JS s√≠ncrono. Lo que entra aqu√≠, bloquea el hilo.</li> <li>Web APIs: Funcionalidades que NO son parte de JS, sino del navegador (DOM, <code>fetch</code>, <code>setTimeout</code>, Geolocalizaci√≥n). Aqu√≠ es donde se ejecutan realmente las tareas as√≠ncronas.</li> <li>Callback Queue (Cola de Callbacks): Lista de espera para funciones listas para ejecutarse (ej. el callback de un <code>setTimeout</code> o un evento <code>click</code>).</li> <li>Microtasks Queue (Cola de Microtareas): Una cola VIP con prioridad alta. Aqu√≠ van las callbacks de las Promesas.</li> </ol> <p>El Event Loop (Bucle de Eventos)</p> <p>Es el coordinador central. Su trabajo es infinito y simple: 1.  Mira el Call Stack. ¬øEst√° vac√≠o? 2.  Si est√° vac√≠o, mira la Microtasks Queue. ¬øHay algo? P√°salo al Stack. 3.  Si no hay microtareas, mira la Callback Queue. Pasa el siguiente elemento al Stack.</p> <p>Regla de Oro: El Event Loop nunca mover√° nada de las colas al Stack hasta que el Stack est√© totalmente vac√≠o (hasta que el c√≥digo s√≠ncrono haya terminado).</p>","path":["JavaScript","Asincron√≠a en JavaScript"],"tags":[]},{"location":"java-script/async/#ajax","level":2,"title":"AJAX","text":"<p>AJAX (Asynchronous JavaScript and XML) es la t√©cnica tradicional para comunicar el cliente con el servidor de forma as√≠ncrona (sin recargar la p√°gina).</p> <p>El problema: Callback Hell</p> <p>Antes de las promesas, gestion√°bamos la asincron√≠a anidando funciones (callbacks). Si ten√≠as que hacer varias peticiones secuenciales (ej. buscar usuario -&gt; buscar sus pedidos -&gt; buscar detalle del pedido), el c√≥digo se volv√≠a una pir√°mide ilegible.</p> <pre><code>// ‚ùå Callback Hell (Dif√≠cil de leer y mantener)\nsetTimeout(() =&gt; {\n    console.log('1. Petici√≥n inicial');\n    setTimeout(() =&gt; {\n        console.log('2. Datos recibidos');\n        setTimeout(() =&gt; {\n            console.log('3. Proceso finalizado');\n        }, 1000);\n    }, 1000);\n}, 1000);\n</code></pre>","path":["JavaScript","Asincron√≠a en JavaScript"],"tags":[]},{"location":"java-script/async/#promesas","level":2,"title":"Promesas","text":"<p>Una Promesa es un objeto contenedor para un valor futuro. Es como un \"recibo\" que te garantiza que recibir√°s un valor (√©xito) o un error (fracaso) m√°s adelante.</p> <p>Estados de una Promesa</p> <ol> <li>Pending (Pendiente): Estado inicial, esperando respuesta.</li> <li>Settled (Resuelta/Finalizada): Ya no est√° pendiente. Puede ser:<ul> <li>Fulfilled (Cumplida): √âxito (ej. datos recibidos).</li> <li>Rejected (Rechazada): Error (ej. servidor ca√≠do).</li> </ul> </li> </ol> <p>Consumir Promesas (<code>.then</code>, <code>.catch</code>, <code>.finally</code>)</p> <p>Usamos la API moderna <code>fetch</code> para pedir datos. <code>fetch</code> devuelve una Promesa inmediatamente.</p> <pre><code>// Ejemplo: Pedir datos de un producto ficticio\nconst request = fetch('[https://api.ejemplo.com/productos/1](https://api.ejemplo.com/productos/1)');\n\nrequest\n    .then(response =&gt; {\n        // fetch devuelve primero los metadatos, hay que convertir el body a JSON\n        // .json() TAMBI√âN es as√≠ncrono y devuelve otra promesa\n        return response.json(); \n    })\n    .then(data =&gt; {\n        // Aqu√≠ ya tenemos los datos finales\n        console.log('Producto:', data.name);\n    })\n    .catch(err =&gt; {\n        // Captura errores de red (ej. sin internet)\n        console.error('‚ö†Ô∏è Error detectado:', err.message);\n    })\n    .finally(() =&gt; {\n        // Se ejecuta SIEMPRE (√∫til para ocultar spinners de carga)\n        console.log('Operaci√≥n terminada');\n    });\n</code></pre> <p>Manejo de Errores Manual (throw)</p> <p>Un detalle crucial de fetch es que no rechaza la promesa en errores HTTP (404, 500). Solo rechaza si falla la red. Debemos lanzar el error manualmente.</p> <pre><code>fetch('url-que-no-existe')\n    .then(response =&gt; {\n        if (!response.ok) { // .ok es false si el status es 404 o 500\n            throw new Error(`Producto no encontrado (${response.status})`);\n        }\n        return response.json();\n    })\n    .catch(err =&gt; console.error(err)); // Aqu√≠ atrapamos nuestro error manual\n</code></pre>","path":["JavaScript","Asincron√≠a en JavaScript"],"tags":[]},{"location":"java-script/async/#construir-promesas","level":2,"title":"Construir Promesas","text":"<p>A veces necesitamos convertir APIs antiguas basadas en callbacks (como <code>setTimeout</code> o <code>navigator.geolocation</code>) en Promesas para usarlas c√≥modamente.</p> <pre><code>// El constructor recibe una funci√≥n ejecutora con dos argumentos: resolve y reject\nconst esperar = function(segundos) {\n    return new Promise((resolve) =&gt; {\n        // Cuando termine el timer, marcamos la promesa como \"Fulfilled\"\n        setTimeout(resolve, segundos * 1000);\n    });\n};\n\n// Uso elegante sin callbacks anidados\nesperar(2)\n    .then(() =&gt; {\n        console.log('Han pasado 2 segundos');\n        return esperar(1);\n    })\n    .then(() =&gt; console.log('Ha pasado 1 segundo m√°s'));\n</code></pre>","path":["JavaScript","Asincron√≠a en JavaScript"],"tags":[]},{"location":"java-script/async/#async-await-es2017","level":2,"title":"Async / Await (ES2017)","text":"<p>Es \"Az√∫car Sint√°ctica\" sobre las Promesas. Permite escribir c√≥digo as√≠ncrono que parece y se comporta como c√≥digo s√≠ncrono.</p> <ul> <li> <p><code>async</code>: Convierte una funci√≥n para que devuelva autom√°ticamente una promesa.</p> </li> <li> <p><code>await</code>: Detiene la ejecuci√≥n de la funci√≥n en esa l√≠nea hasta que la promesa se resuelve. (No bloquea el Call Stack principal, solo la funci√≥n).</p> </li> </ul> <pre><code>const obtenerDatosUsuario = async function() {\n    // try...catch es la forma est√°ndar de JS para errores, usada aqu√≠\n    try {\n        const res = await fetch('[https://api.ejemplo.com/usuario/1](https://api.ejemplo.com/usuario/1)');\n\n        if (!res.ok) throw new Error('Error en la petici√≥n');\n\n        const data = await res.json();\n        console.log(`Usuario: ${data.name}`);\n\n        return data; // Esto ser√° el valor \"resolved\" de la promesa que devuelve la funci√≥n\n\n    } catch (err) {\n        console.error('Error capturado:', err.message);\n        // Importante: Si queremos que el error se propague fuera, debemos relanzarlo\n        throw err;\n    }\n};\n</code></pre>","path":["JavaScript","Asincron√≠a en JavaScript"],"tags":[]},{"location":"java-script/async/#ejecucion-en-paralelo","level":2,"title":"Ejecuci√≥n en Paralelo","text":"<p>A veces necesitamos hacer varias peticiones que no dependen una de la otra. Si usamos <code>await</code> una tras otra, perdemos tiempo. Para esto usamos los m√©todos est√°ticos de <code>Promise</code>.</p> <p>1. <code>Promise.all([prom1, prom2])</code> (Todo o Nada)</p> <ul> <li> <p>Ejecuta todas las promesas a la vez (en paralelo).</p> </li> <li> <p>√âxito: Devuelve un array con todos los resultados en el mismo orden de entrada.</p> </li> <li> <p>Fallo: Si UNA falla, todo explota (Short-circuit). La promesa global se rechaza inmediatamente con ese error.</p> </li> </ul> <pre><code>const obtenerVarios = async function() {\n    try {\n        const data = await Promise.all([\n            fetch('[https://api.com/users](https://api.com/users)'),\n            fetch('[https://api.com/orders](https://api.com/orders)'),\n            fetch('[https://api.com/products](https://api.com/products)')\n        ]);\n\n        // data es un array de respuestas [resUsers, resOrders, resProducts]\n        const responses = await Promise.all(data.map(res =&gt; res.json()));\n        console.log(responses[0]); // Usuarios\n    } catch (err) {\n        console.error(err);\n    }\n};\n</code></pre> <p>2. Promise.race([prom1, prom2]) (El m√°s r√°pido)</p> <ul> <li> <p>Devuelve el resultado de la primera promesa que se complete (ya sea √©xito o error).</p> </li> <li> <p>Uso com√∫n: Temporizadores de cancelaci√≥n (Timeout). Si la petici√≥n tarda m√°s de X segundos, la rechazamos manualmente.</p> </li> </ul> <pre><code>const timeout = function(sec) {\n    return new Promise((_, reject) =&gt; {\n        setTimeout(() =&gt; reject(new Error('La petici√≥n tard√≥ demasiado')), sec * 1000);\n    });\n};\n\n// Competici√≥n: Petici√≥n real vs Timer de 5 segundos\nPromise.race([\n    fetch('[https://api.lenta.com/datos](https://api.lenta.com/datos)'),\n    timeout(5)\n])\n.then(res =&gt; console.log(res))\n.catch(err =&gt; console.error(err));\n</code></pre> <p>3. Promise.allSettled([prom1, prom2]) (ES2020)</p> <ul> <li> <p>Espera a que todas terminen, sin importar si fallaron o no.</p> </li> <li> <p>Nunca hace cortocircuito.</p> </li> <li> <p>Devuelve un array de objetos con el estado detallado:</p> <ul> <li> <p>{ status: 'fulfilled', value: ... }</p> </li> <li> <p>{ status: 'rejected', reason: ... }</p> </li> </ul> </li> </ul> <p>4. Promise.any([prom1, prom2]) (ES2021)</p> <ul> <li> <p>Busca el primer √©xito (primera promesa fulfilled).</p> </li> <li> <p>Ignora los errores (rejected) a menos que todas fallen.</p> </li> <li> <p>Es conceptualmente lo opuesto a Promise.all.</p> </li> </ul>","path":["JavaScript","Asincron√≠a en JavaScript"],"tags":[]},{"location":"java-script/oop/","level":1,"title":"Programaci√≥n Orientada a Objetos (OOP)","text":"<p>Estos apuntes recogen los fundamentos y patrones de dise√±o de la Programaci√≥n Orientada a Objetos (OOP) en JavaScript.</p> <p>Nota Importante:</p> <p>El contenido hace especial hincapi√© en las Clases de ES6, ya que representan el est√°ndar moderno y profesional m√°s utilizado en la industria actual.</p> <p>Aunque se explican las mec√°nicas subyacentes y tradicionales (como las Constructor Functions y <code>Object.create</code>) para comprender c√≥mo funciona el motor por debajo, no se cubren todos sus casos borde. En caso de necesitar profundizar en sintaxis legacy o detalles muy espec√≠ficos de implementaciones antiguas, documentaci√≥n oficial de MDN.</p>","path":["JavaScript","Programaci√≥n Orientada a Objetos (OOP)"],"tags":[]},{"location":"java-script/oop/#conceptos-fundamentales-de-oop","level":2,"title":"Conceptos Fundamentales de OOP","text":"<p>¬øQu√© es la OOP? Es un paradigma de programaci√≥n basado en el concepto de objetos. Usamos objetos para modelar aspectos del mundo real (ej. un usuario, una lista de tareas) o abstracto (ej. estructura de datos HTML).</p> <ul> <li>Los objetos contienen datos (propiedades) y c√≥digo (m√©todos).</li> <li>Los objetos son bloques de construcci√≥n \"autocontenidos\".</li> <li>Interact√∫an entre s√≠ a trav√©s de una API p√∫blica (m√©todos accesibles).</li> </ul> <p>Los 4 Pilares de la OOP</p> <ol> <li>Abstracci√≥n: Ignorar u ocultar los detalles complejos \"under the hood\" (como funciona por dentro) y exponer solo lo necesario (ej. usar <code>addEventListener</code> sin saber c√≥mo el navegador maneja el evento internamente).</li> <li>Encapsulamiento: Mantener propiedades y m√©todos privados dentro de la clase, inaccesibles desde fuera. Esto previene que el estado se modifique accidentalmente por c√≥digo externo. (En JS \"tradicional\" es dif√≠cil, pero existen convenciones y m√©todos modernos).</li> <li>Herencia: Hacer que una clase (hija) herede propiedades y m√©todos de otra clase (padre). Evita duplicar c√≥digo.</li> <li>Polimorfismo: Una clase hija puede sobrescribir un m√©todo heredado del padre para adaptarlo a sus necesidades.</li> </ol>","path":["JavaScript","Programaci√≥n Orientada a Objetos (OOP)"],"tags":[]},{"location":"java-script/oop/#prototipos","level":2,"title":"Prototipos","text":"<p>A diferencia de lenguajes \"Cl√°sicos\" (Java, C++, Python) donde las clases copian su comportamiento a las instancias, JavaScript utiliza Prototipos.</p> <ul> <li>Herencia Protot√≠pica (Prototypal Inheritance): Todos los objetos en JS est√°n vinculados a un objeto prototipo.</li> <li>Delegaci√≥n: Cuando intentamos acceder a una propiedad o m√©todo en un objeto, si JS no lo encuentra all√≠, busca en su prototipo. El objeto \"delega\" la tarea.</li> </ul> <p>Las 3 formas de implementar OOP en JS</p> <ol> <li>Constructor Functions (Funciones Constructoras): T√©cnica desde el inicio de JS. Se usan funciones normales llamadas con <code>new</code>.</li> <li>ES6 Classes: Sintaxis moderna (2015). IMPORTANTE: Es solo \"Az√∫car Sint√°ctica\" (Syntactic Sugar). Por debajo siguen siendo funciones constructoras y prototipos; no cambiaron c√≥mo funciona el lenguaje, solo c√≥mo se escribe.</li> <li>Object.create(): La forma m√°s directa de vincular un objeto a un prototipo espec√≠fico (menos com√∫n en el d√≠a a d√≠a b√°sico).</li> </ol>","path":["JavaScript","Programaci√≥n Orientada a Objetos (OOP)"],"tags":[]},{"location":"java-script/oop/#constructor-functions","level":2,"title":"Constructor Functions","text":"<p>Las Funciones Constructoras son patrones para crear objetos program√°ticamente.</p> <ul> <li> <p>Convenci√≥n: Siempre empezar con May√∫scula (<code>PersonObject</code>, no <code>personObject</code>).</p> </li> <li> <p>Restricci√≥n: No se pueden usar Arrow Functions porque no tienen su propio <code>this</code>.</p> </li> </ul> <p>Proceso de Ejecuci√≥n (Los 4 pasos de <code>new</code>)</p> <p>Cuando ejecutamos <code>const jonas = new Person('Jonas', 1991);</code>, el motor hace esto:</p> <ol> <li> <p>Creaci√≥n: Se crea un nuevo objeto vac√≠o <code>{}</code>.</p> </li> <li> <p>Binding: El <code>this</code> de la funci√≥n se asigna a ese nuevo objeto.</p> </li> <li> <p>Linking (Enlace): El nuevo objeto se vincula a su prototipo (<code>__proto__</code> se conecta a <code>Person.prototype</code>).</p> </li> <li> <p>Return: La funci√≥n devuelve autom√°ticamente el objeto.</p> </li> </ol> <pre><code>const Person = function(firstName, birthYear) {\n    // Propiedades de instancia (Instance Properties)\n    this.firstName = firstName;\n    this.birthYear = birthYear;\n\n    // ‚õîÔ∏è NUNCA crear m√©todos dentro del constructor\n    // this.calcAge = function() { ... };\n    // Raz√≥n: Cada nueva instancia crear√≠a una copia de la funci√≥n.\n    // Si tienes 1000 usuarios, tendr√≠as 1000 copias id√©nticas en memoria.\n};\n\nconst matilda = new Person('Matilda', 2017);\n// matilda es una INSTANCIA de Person\n</code></pre> <ul> <li>Cada funci√≥n en JS (incluidos los constructores) tiene una propiedad llamada <code>.prototype</code>.</li> </ul> <p>Regla de Oro: * <code>Person.prototype</code> NO es el prototipo de <code>Person</code>. * Es el prototipo que usar√°n los objetos creados por <code>Person</code>.</p>","path":["JavaScript","Programaci√≥n Orientada a Objetos (OOP)"],"tags":[]},{"location":"java-script/oop/#anadiendo-metodos-solucion-de-rendimiento","level":3,"title":"A√±adiendo m√©todos (Soluci√≥n de rendimiento)","text":"<ul> <li>A√±adimos los m√©todos al objeto <code>prototype</code>.</li> <li>As√≠ solo existe una copia en memoria y todas las instancias la comparten mediante referencia.</li> </ul> <pre><code>// Prototypal Inheritance en acci√≥n  \nPerson.prototype.calcAge = function() {  \n    console.log(2037 - this.birthYear);  \n};\n\nmatilda.calcAge(); // 20  \n\n* JS busca `calcAge` en `matilda` ‚Üí No est√°.\n* Mira el prototipo (`matilda.__proto__`) ‚Üí Ah√≠ est√°. Lo ejecuta.\n</code></pre>","path":["JavaScript","Programaci√≥n Orientada a Objetos (OOP)"],"tags":[]},{"location":"java-script/oop/#propiedades-y-verificacion","level":3,"title":"Propiedades y Verificaci√≥n","text":"<ul> <li><code>__proto__</code>: Propiedad de la instancia que apunta al prototipo del constructor.</li> </ul> <p>matilda.proto === Person.prototype // true  </p> <ul> <li><code>isPrototypeOf</code>: M√©todo para comprobar la vinculaci√≥n.</li> </ul> <p>Person.prototype.isPrototypeOf(matilda) // true  </p> <p>Person.prototype.isPrototypeOf(Person) // false (Confusi√≥n com√∫n)</p>","path":["JavaScript","Programaci√≥n Orientada a Objetos (OOP)"],"tags":[]},{"location":"java-script/oop/#propiedades-propias-vs-heredadas","level":3,"title":"Propiedades propias vs Heredadas","text":"<ul> <li>Tambi√©n podemos poner propiedades en el prototipo (<code>Person.prototype.species = 'Homo Sapiens'</code>).</li> </ul> <p>matilda.hasOwnProperty('firstName') // true (Est√° en el objeto)  </p> <p>matilda.hasOwnProperty('species') // false (Est√° en el prototipo)</p>","path":["JavaScript","Programaci√≥n Orientada a Objetos (OOP)"],"tags":[]},{"location":"java-script/oop/#prototypal-inheritance-y-the-prototype-chain","level":3,"title":"Prototypal Inheritance y The Prototype Chain","text":"<ul> <li>La \"Cadena de Prototipos\" es la serie de enlaces entre objetos.</li> <li>Es similar al Scope Chain, pero para buscar propiedades.</li> </ul>","path":["JavaScript","Programaci√≥n Orientada a Objetos (OOP)"],"tags":[]},{"location":"java-script/oop/#el-flujo-de-busqueda-lookup","level":4,"title":"El flujo de b√∫squeda (Lookup)","text":"<ol> <li>Busca en el objeto propio.</li> <li>Si no encuentra, mira en su <code>__proto__</code>.</li> <li>Si no encuentra, mira en el <code>__proto__</code> de ese prototipo.</li> <li>Contin√∫a hasta llegar a <code>Object.prototype</code> (el tope de la cadena).</li> <li>Si supera eso, llega a <code>null</code> y devuelve <code>undefined</code>.</li> </ol>","path":["JavaScript","Programaci√≥n Orientada a Objetos (OOP)"],"tags":[]},{"location":"java-script/oop/#visualizacion-de-la-cadena-ejemplo-person","level":4,"title":"Visualizaci√≥n de la cadena (Ejemplo Person)","text":"<p>matilda ‚Üí Person.prototype ‚Üí Object.prototype ‚Üí null  </p> <ul> <li><code>matilda</code>: Tiene <code>firstName</code>, <code>birthYear</code>.</li> <li><code>Person.prototype</code>: Tiene <code>calcAge</code>, <code>species</code>.</li> <li><code>Object.prototype</code>: Tiene m√©todos universales como <code>.hasOwnProperty()</code>, <code>.toString()</code>.</li> </ul>","path":["JavaScript","Programaci√≥n Orientada a Objetos (OOP)"],"tags":[]},{"location":"java-script/oop/#prototypal-inheritance-en-objetos-nativos","level":3,"title":"Prototypal Inheritance en Objetos Nativos.","text":"<ul> <li>Cualquier array, funci√≥n o elemento DOM en JS funciona igual.</li> </ul>","path":["JavaScript","Programaci√≥n Orientada a Objetos (OOP)"],"tags":[]},{"location":"java-script/oop/#arrays","level":4,"title":"Arrays","text":"<ul> <li>Cuando haces <code>const arr = [1, 2, 3]</code>, es una abreviatura de <code>new Array(1, 2, 3)</code>.</li> <li> <p><code>arr</code> hereda de <code>Array.prototype</code>.</p> </li> <li> <p>Por eso tienes acceso a <code>.map</code>, <code>.filter</code>, <code>.push</code>.</p> </li> <li>Esos m√©todos no est√°n en tu array, est√°n en el prototipo maestro de <code>Array</code>.</li> </ul>","path":["JavaScript","Programaci√≥n Orientada a Objetos (OOP)"],"tags":[]},{"location":"java-script/oop/#extender-prototipos-mala-practica","level":4,"title":"Extender Prototipos (Mala Pr√°ctica)","text":"<ul> <li>Podr√≠as hacer esto:</li> </ul> <pre><code>Array.prototype.unique = function() {  \n    return [...new Set(this)];  \n};\n</code></pre> <ul> <li>Aunque funciona, no se recomienda:</li> <li>La pr√≥xima versi√≥n de JS podr√≠a a√±adir un m√©todo con el mismo nombre y romper tu c√≥digo.</li> <li>En equipos grandes genera confusi√≥n sobre qu√© m√©todos son est√°ndar y cu√°les custom.</li> </ul>","path":["JavaScript","Programaci√≥n Orientada a Objetos (OOP)"],"tags":[]},{"location":"java-script/oop/#classes","level":2,"title":"Classes","text":"<p>Introducidas en ECMAScript 2015, son la sintaxis moderna para hacer OOP en JavaScript.</p> <p>Es vital entender que las clases en JS NO funcionan como en Java o C++.</p> <ul> <li> <p>No traen un nuevo modelo de herencia: Por debajo, siguen utilizando Funciones Constructoras y Herencia Protot√≠pica.</p> </li> <li> <p>Son simplemente una capa est√©tica (\"az√∫car\") para escribir lo mismo de forma m√°s limpia y organizada.</p> </li> <li> <p><code>class</code>: Palabra clave para definirla.</p> </li> <li> <p><code>constructor()</code>: M√©todo obligatorio (con ese nombre exacto) que funciona igual que la funci√≥n constructora antigua. Se ejecuta inmediatamente al usar <code>new</code>.</p> </li> <li> <p>M√©todos: Se escriben dentro de la clase, pero fuera del constructor. Autom√°ticamente se a√±aden al <code>.prototype</code>.</p> </li> </ul> <pre><code>// Class expression\n// const PersonCl = class {}\n\n// Class declaration\nclass PersonCl {\n    constructor(firstName, birthYear) {\n        this.firstName = firstName;\n        this.birthYear = birthYear;\n    }\n\n    // Los m√©todos se a√±adir√°n a .prototype autom√°ticamente\n    calcAge() {\n        console.log(2037 - this.birthYear);\n    }\n}\n\nconst jessica = new PersonCl('Jessica', 1996);\njessica.calcAge(); \n// jessica.__proto__ === PersonCl.prototype (TRUE)\n</code></pre> <ul> <li> <p>No Hoisting: A diferencia de las declaraciones de funciones, las clases no se elevan. Debes definirlas antes de usarlas.</p> </li> <li> <p>First-Class Citizens: Se pueden pasar a funciones y retornar desde funciones.</p> </li> <li> <p>Strict Mode: El cuerpo de una clase se ejecuta siempre en \"use strict\", incluso si no lo activaste en el archivo.</p> </li> </ul>","path":["JavaScript","Programaci√≥n Orientada a Objetos (OOP)"],"tags":[]},{"location":"java-script/oop/#getters-y-setters","level":3,"title":"Getters y Setters","text":"<p>Son propiedades especiales que parecen valores normales pero que por debajo ejecutan funciones. Sirven para transformar datos al leerlos (<code>get</code>) o validarlos al escribirlos (<code>set</code>).</p> <p>En Objetos Literales <pre><code>const account = {\n    owner: 'Jonas',\n    movements: [200, 530, 120, 300],\n\n    // GETTER: Se usa como propiedad, no como funci√≥n\n    get latest() {\n        return this.movements.slice(-1).pop();\n    },\n\n    // SETTER: Debe tener exactamente un par√°metro\n    set latest(mov) {\n        this.movements.push(mov);\n    }\n};\n\nconsole.log(account.latest); // 300 (Sin par√©ntesis)\naccount.latest = 50;         // Se asigna con =\n</code></pre></p> <p>En Clases: Validaci√≥n de Datos</p> <p>Un patr√≥n muy com√∫n es usar Setters para validar datos al momento de crear el objeto.</p> <ul> <li> <p>El conflicto de nombres: Si el setter se llama igual que la propiedad del constructor (ej. <code>fullName</code>), se crea un bucle infinito (Stack Overflow).</p> </li> <li> <p>Soluci√≥n: Usar la convenci√≥n <code>_</code> (guion bajo) para crear una variable \"privada\" temporal.</p> </li> </ul> <pre><code>class PersonCl {\n    constructor(fullName, birthYear) {\n        this.fullName = fullName; // Esto dispara el setter autom√°ticamente\n        this.birthYear = birthYear;\n    }\n\n    // Validaci√≥n: El nombre debe tener espacios\n    set fullName(name) {\n        if (name.includes(' ')) {\n            this._fullName = name; // Guardamos en variable con _\n        } else {\n            alert(`${name} is not a full name!`);\n        }\n    }\n\n    get fullName() {\n        return this._fullName; // Devolvemos la variable con _\n    }\n}\n</code></pre>","path":["JavaScript","Programaci√≥n Orientada a Objetos (OOP)"],"tags":[]},{"location":"java-script/oop/#static-methods","level":3,"title":"Static Methods","text":"<p>Son m√©todos que est√°n adjuntos al Constructor (la clase en s√≠), no al prototipo. Por tanto, las instancias (los objetos creados) NO pueden usarlos.</p> <ul> <li> <p>Ejemplo nativo: <code>Array.from()</code>.</p> <ul> <li> <p><code>Array.from(document.querySelectorAll('h1'))</code> funciona.</p> </li> <li> <p><code>[1, 2, 3].from()</code> falla, porque <code>.from</code> no est√° en el prototipo de los arrays, est√° en el constructor <code>Array</code>.</p> </li> </ul> </li> </ul> <p>Creaci√≥n en Clases</p> <p>Se usa la palabra clave <code>static</code>. Son √∫tiles para funciones de utilidad (helpers) relacionadas con la clase pero que no dependen de una instancia espec√≠fica.</p> <pre><code>class PersonCl {\n    constructor(firstName) {\n        this.firstName = firstName;\n    }\n\n    // M√©todo de Instancia (Heredable)\n    calcAge() { console.log('Edad...'); }\n\n    // M√©todo Est√°tico (Solo accesible desde PersonCl)\n    static hey() {\n        console.log('Hey there üëã');\n        console.log(this); // Aqu√≠ 'this' es la CLASE completa, no el objeto\n    }\n}\n\nPersonCl.hey(); // Funciona\n// jessica.hey(); // Error: jessica.hey is not a function\n</code></pre>","path":["JavaScript","Programaci√≥n Orientada a Objetos (OOP)"],"tags":[]},{"location":"java-script/oop/#herencia-entre-clases","level":3,"title":"Herencia entre Clases","text":"<p>La herencia permite que una clase hija (Child) derive funcionalidades de una clase padre (Parent).</p> <p>Se utilizan dos palabras clave fundamentales:</p> <ol> <li> <p><code>extends</code>: Establece la relaci√≥n de herencia. Conecta los prototipos por debajo.</p> </li> <li> <p><code>super</code>: Funci√≥n especial que llama al constructor de la clase padre.</p> </li> </ol> <p>Cuando una clase extiende a otra, el comportamiento del <code>constructor</code> cambia dr√°sticamente:</p> <ol> <li> <p>Si NO necesitas nuevas propiedades:</p> <p>No hace falta escribir un <code>constructor</code> en la clase hija. JS lo invoca autom√°ticamente y pasa los argumentos al padre.</p> </li> <li> <p>Si S√ç necesitas nuevas propiedades (El caso com√∫n):</p> <ul> <li> <p>Debes escribir el constructor.</p> </li> <li> <p>OBLIGATORIO: Debes llamar a <code>super()</code> antes de usar la palabra clave <code>this</code>.</p> </li> <li> <p>¬øPor qu√©? En una clase derivada, el objeto <code>this</code> no se crea hasta que se ejecuta <code>super()</code>. Si intentas acceder a <code>this</code> antes, obtendr√°s un ReferenceError.</p> </li> </ul> </li> </ol> <pre><code>class PersonCl {\n    constructor(fullName, birthYear) {\n        this.fullName = fullName;\n        this.birthYear = birthYear;\n    }\n\n    calcAge() { console.log(2037 - this.birthYear); }\n}\n\n// StudentCl HEREDA de PersonCl\nclass StudentCl extends PersonCl {\n    constructor(fullName, birthYear, course) {\n        // 1. Siempre primero: Llamada al constructor padre\n        // Esto crea el 'this' inicial\n        super(fullName, birthYear);\n\n        // 2. Luego a√±adimos las propiedades nuevas\n        this.course = course;\n    }\n\n    introduce() {\n        console.log(`Hola, soy ${this.fullName} y estudio ${this.course}`);\n    }\n\n    // Polimorfismo: Sobrescribir un m√©todo del padre\n    calcAge() {\n        console.log(`Soy estudiante y tengo ${2037 - this.birthYear} a√±os (m√°s o menos)`);\n    }\n}\n\nconst martha = new StudentCl('Martha Jones', 2002, 'Computer Science');\nmartha.introduce(); // Usa m√©todo propio\nmartha.calcAge();   // Usa m√©todo sobrescrito\n</code></pre>","path":["JavaScript","Programaci√≥n Orientada a Objetos (OOP)"],"tags":[]},{"location":"java-script/oop/#encapsulamiento-class-fields","level":3,"title":"Encapsulamiento: Class Fields","text":"<p>Durante mucho tiempo, JS no tuvo privacidad real. Se usaba la convenci√≥n <code>_propiedad</code> (guion bajo), pero eso no imped√≠a que alguien modificara el dato desde fuera (\"Fake Encapsulation\").</p> <p>La propuesta moderna de Class Fields introduce 4 tipos de campos para solucionar esto y limpiar la sintaxis.</p> <p>Public Fields</p> <p>Son variables que se definen al nivel superior de la clase (fuera del constructor).</p> <ul> <li> <p>Diferencia clave: Se a√±aden a todas las instancias (al objeto en s√≠), NO al prototipo.</p> </li> <li> <p>No usan <code>const</code> ni <code>let</code>.</p> </li> </ul> <pre><code>class Account {\n    // Public Fields (Instancias)\n    locale = navigator.language;\n\n    // Estos campos estar√°n presentes en CADA objeto creado\n    constructor(owner, currency) {\n        this.owner = owner;\n        this.currency = currency;\n    }\n}\n</code></pre> <p>Private Fields</p> <p>Utilizan el s√≠mbolo almohadilla <code>#</code>.</p> <ul> <li> <p>Seguridad: Son verdaderamente privados. Si intentas acceder a ellos desde fuera de la clase (<code>acc.#movements</code>), JS lanzar√° un error de sintaxis.</p> </li> <li> <p>Regla: Deben declararse (definirse) arriba del todo, fuera del constructor, antes de usarse dentro.</p> </li> </ul> <p><pre><code>class Account {\n    // 1. Definici√≥n obligatoria al inicio\n    #movements = [];\n    #pin; // Podemos definir sin inicializar\n\n    constructor(owner, currency, pin) {\n        this.owner = owner;\n        this.currency = currency;\n\n        // 2. Asignaci√≥n dentro del constructor\n        this.#pin = pin;\n        // this.#movements es accesible aqu√≠ dentro\n    }\n\n    // API P√∫blica para interactuar con datos privados\n    deposit(val) {\n        this.#movements.push(val);\n    }\n\n    getMovements() {\n        return this.#movements;\n    }\n}\n\nconst acc1 = new Account('Jonas', 'EUR', 1111);\nacc1.deposit(100);\n// console.log(acc1.#movements); ‚ùå ERROR: Private field '#movements' must be declared in an enclosing class\n</code></pre> Private Methods</p> <ul> <li> <p>Sintaxis: <code>#nombreMetodo()</code>.</p> </li> <li> <p>√ötiles para l√≥gica interna auxiliar que no quieres que el usuario final toque.</p> </li> <li> <p>(Nota: El soporte en navegadores para esto lleg√≥ un poco m√°s tarde que para los campos, pero hoy es est√°ndar).</p> </li> </ul> <pre><code>class Account {\n    // M√©todo p√∫blico\n    requestLoan(val) {\n        if (this.#approveLoan(val)) {\n            this.deposit(val);\n            console.log('Pr√©stamo aprobado');\n        }\n    }\n\n    // M√©todo Privado (Solo accesible dentro de la clase)\n    #approveLoan(val) {\n        return true; // L√≥gica compleja oculta\n    }\n}\n</code></pre> <p>Static Public/Private Fields</p> <p>Podemos combinar static con lo anterior.</p> <ul> <li> <p><code>static numInstances</code> = 0; -&gt; Accesible solo como Account.numInstances.</p> </li> <li> <p><code>static #helper()</code> -&gt; Accesible solo dentro de la clase.</p> </li> </ul>","path":["JavaScript","Programaci√≥n Orientada a Objetos (OOP)"],"tags":[]},{"location":"java-script/oop/#objectcreate","level":2,"title":"Object.create()","text":"<p>Es la tercera forma de implementar herencia protot√≠pica. Es la m√°s \"pura\" porque desconecta la idea de clases/constructores y simplemente vincula objetos con objetos.</p> <p>Funcionamiento</p> <ul> <li> <p>No usa <code>new</code>.</p> </li> <li> <p>No usa <code>.prototype</code> property de la misma forma simulada.</p> </li> <li> <p>No tiene constructor autom√°tico.</p> </li> </ul> <p>Simplemente creas un objeto que servir√° de prototipo, y luego creas nuevos objetos dici√©ndoles expl√≠citamente: \"Tu prototipo ser√° este objeto de aqu√≠\".</p> <pre><code>// 1. Definimos el objeto que servir√° de Prototipo\nconst PersonProto = {\n    calcAge() {\n        console.log(2037 - this.birthYear);\n    },\n\n    // Funci√≥n manual para inicializar (no es un constructor real)\n    init(firstName, birthYear) {\n        this.firstName = firstName;\n        this.birthYear = birthYear;\n    }\n};\n\n// 2. Creamos el objeto vinculado\n// 'steven' ser√° un objeto vac√≠o con PersonProto en su __proto__\nconst steven = Object.create(PersonProto);\n\nconsole.log(steven); // {}\nsteven.name = 'Steven';\nsteven.birthYear = 2002;\nsteven.calcAge(); // Funciona por delegaci√≥n\n\n// 3. Manera m√°s organizada usando el m√©todo init manual\nconst sarah = Object.create(PersonProto);\nsarah.init('Sarah', 1979);\nsarah.calcAge();\n</code></pre>","path":["JavaScript","Programaci√≥n Orientada a Objetos (OOP)"],"tags":[]},{"location":"java-script/standard-built-in-objects/","level":1,"title":"Standard Built-in Objects","text":"","path":["JavaScript","Standard Built-in Objects"],"tags":[]},{"location":"java-script/standard-built-in-objects/#introduccion","level":2,"title":"Introducci√≥n","text":"<p>En JavaScript, no empiezas desde cero. El lenguaje viene con una \"caja de herramientas\" preinstalada lista para usar en cualquier parte de tu c√≥digo, sin necesidad de importar librer√≠as externas. A estos se les llama Objetos Est√°ndar Incorporados.</p> <p>¬øQu√© son exactamente?</p> <p>Son objetos que existen en el √°mbito global (Global Scope). Esto significa que est√°n disponibles en cualquier script y en cualquier momento.</p> <p>Se dividen principalmente en tres categor√≠as:</p> <ol> <li>Envoltorios de Primitivos: Objetos que nos permiten tratar datos simples (texto, n√∫meros) como si fueran objetos complejos (<code>String</code>, <code>Number</code>, <code>Boolean</code>).</li> <li>Estructuras de Datos: Herramientas para organizar informaci√≥n (<code>Array</code>, <code>Map</code>, <code>Set</code>, <code>Object</code>).</li> <li>Utilidades: Objetos que funcionan como una librer√≠a de funciones matem√°ticas, manejo de fechas o procesamiento de datos (<code>Math</code>, <code>Date</code>, <code>JSON</code>).</li> </ol> <p>¬øQu√© nos proporcionan?</p> <p>Estos objetos nos facilitan la vida proporcionando dos cosas clave: Propiedades (datos) y M√©todos (acciones).</p> <ol> <li> <p>M√©todos de manipulaci√≥n En lugar de escribir una funci√≥n compleja para buscar un texto dentro de otro, el objeto <code>String</code> ya trae <code>.includes()</code>. En lugar de calcular una ra√≠z cuadrada a mano, <code>Math</code> trae <code>.sqrt()</code>.</p> </li> <li> <p>Conversi√≥n de Tipos Nos permiten transformar datos de un tipo a otro de forma segura. Ejemplo: <code>Number(\"10\")</code> convierte un string a n√∫mero.</p> </li> <li> <p>Constantes Universales Valores que nunca cambian y son necesarios matem√°ticamente o por configuraci√≥n. Ejemplo: <code>Math.PI</code> o <code>Number.MAX_VALUE</code>.</p> </li> </ol> <p>Esta secci√≥n explica la arquitectura interna de los objetos nativos de JavaScript.</p> <p>Dado que la cantidad de m√©todos y propiedades integrados es extensa y var√≠a entre versiones, estos apuntes no pretenden ser una referencia exhaustiva, sino orientativa, mostrando las m√°s usadas.</p> <p>Para consultar la lista completa, actualizada y detallada de m√©todos para cada objeto, es mejor recurrir siempre a la referencia oficial:</p> <ul> <li>MDN Web Docs - Standard Built-in Objects</li> </ul>","path":["JavaScript","Standard Built-in Objects"],"tags":[]},{"location":"java-script/standard-built-in-objects/#strings","level":2,"title":"Strings","text":"<p>JavaScript proporciona una gran cantidad de m√©todos para manipular texto.</p> <p>‚ö†Ô∏è Inmutabilidad: Recuerda que los Strings en JS son inmutables. Ninguno de estos m√©todos modifica la variable original; todos devuelven un nuevo string con los cambios aplicados.</p>","path":["JavaScript","Standard Built-in Objects"],"tags":[]},{"location":"java-script/standard-built-in-objects/#longitud","level":3,"title":"Longitud","text":"<p>length</p> <p><pre><code>const str = 'hola';\nconsole.log(str.length); // 4\n</code></pre> Devuelve el n√∫mero de caracteres de un string.</p> <p>‚ö†Ô∏è OJO: Es una propiedad, no un m√©todo, por lo tanto no se llama con los ()</p>","path":["JavaScript","Standard Built-in Objects"],"tags":[]},{"location":"java-script/standard-built-in-objects/#acceso-a-caracteres","level":3,"title":"Acceso a caracteres","text":"<p>Para obtener un car√°cter a trav√©s de un √≠ndice podemos hacerlo de la forma normal con [] o con el m√©todo .at()(√≠ndices negativos)</p> <pre><code>const str = 'Hola';\nconsole.log(str[0]); // H\n// [] vs .at()\nconsole.log(str[str.length - 1]); // a\nconsole.log(str.at(-1)); // a\n</code></pre>","path":["JavaScript","Standard Built-in Objects"],"tags":[]},{"location":"java-script/standard-built-in-objects/#capitalizacion","level":3,"title":"Capitalizaci√≥n","text":"<pre><code>const str = 'Hola';\nconsole.log(str.toLowerCase); // hola\nconsole.log(str.toUpperCase); // HOLA\n</code></pre>","path":["JavaScript","Standard Built-in Objects"],"tags":[]},{"location":"java-script/standard-built-in-objects/#subcadenas","level":3,"title":"Subcadenas","text":"<p>str.indexOf <pre><code>const frase = \"El gato persigue al rat√≥n y el gato juega.\";\n\n// 1. B√∫squeda b√°sica\n// Encuentra la primera vez que aparece \"gato\"\nconst primeraPosicion = frase.indexOf(\"gato\");\nconsole.log(primeraPosicion); \n// Salida: 3 (Recuerda: los √≠ndices empiezan a contar en 0: E-0, l-1, [espacio]-2, g-3)\n\n\n// 2. Cuando el texto NO existe\n// Si no lo encuentra, siempre devuelve -1\nconst noEncontrado = frase.indexOf(\"perro\");\nconsole.log(noEncontrado); \n// Salida: -1\n\n\n// 3. Case Sensitive (Distingue may√∫sculas)\n// \"Gato\" con may√∫scula no es lo mismo que \"gato\"\nconst mayuscula = frase.indexOf(\"Gato\");\nconsole.log(mayuscula); \n// Salida: -1\n\n\n// 4. Usando el segundo par√°metro (fromIndex)\n// Le decimos: \"Empieza a buscar a partir del √≠ndice 10\"\n// As√≠ saltamos el primer \"gato\" y encontramos el segundo\nconst segundaPosicion = frase.indexOf(\"gato\", 10);\nconsole.log(segundaPosicion); \n// Salida: 31 (La posici√≥n del segundo \"gato\")\n\n// 5. Comprobaci√≥n en condiciones \nif (frese.indexOf('El') != -1) {\n    console.log('Existe');\n}\n// debemos realizarlo as√≠ ya que en casos como este que la subcadena\n// comienza en cero, no entrar√≠a por el if correctamente.\n</code></pre></p> <p>includes, startsWith, endsWith</p> <p><pre><code>const texto = \"Curso de JavaScript\";\n\n// 1. includes() -&gt; ¬øContiene este texto en cualquier parte?\nconsole.log(texto.includes(\"JavaScript\")); // true\nconsole.log(texto.includes(\"Python\"));     // false\n\n\n// 2. startsWith() -&gt; ¬øEmpieza exactamente con esto?\nconsole.log(texto.startsWith(\"Curso\"));    // true\nconsole.log(texto.startsWith(\"curso\"));    // false \n\n\n// 3. endsWith() -&gt; ¬øTermina exactamente con esto?\nconsole.log(texto.endsWith(\"Script\"));     // true\nconsole.log(texto.endsWith(\"Java\"));\n</code></pre> substring y slice</p> <p>Ambos sirven para extraer una parte del string sin modificar el original. Funcionan casi igual (inicio, fin), pero tienen diferencias clave en los casos \"raros\".</p> <p>El par√°metro fin es exclusivo (no se incluye el car√°cter de esa posici√≥n).</p> <pre><code>const str = \"JavaScript\";\n\n// 1. Uso B√°sico (Id√©nticos)\n// Extraer desde √≠ndice 0 hasta el 4 (sin incluir el 4)\nconsole.log(str.slice(0, 4));      // \"Java\"\nconsole.log(str.substring(0, 4));  // \"Java\"\n\nconsole.log(str.slice(4)) // desde el 4 hacia adelante\nstr.slice(-4, -1) // rip, slice permite negativos\n</code></pre> M√©todo Selecciona‚Ä¶ Negativos <code>slice(comienzo, final)</code> Desde <code>comienzo</code> hasta <code>final</code> (sin incluir <code>final</code>) Permite negativos <code>substring(comienzo, final)</code> Entre <code>comienzo</code> y <code>final</code> (no incluye <code>final</code>) Valores negativos se tratan como <code>0</code> <p>Lo recomendable es usar slice.</p>","path":["JavaScript","Standard Built-in Objects"],"tags":[]},{"location":"java-script/standard-built-in-objects/#compararar-strings","level":3,"title":"Compararar strings","text":"<p>Los strings en JavaScript son codificados usando UTF-16. Por lo que cuando ordenamos se basan en esto.</p> <p>str.codePointAt(pos)</p> <p>Devuelve un n√∫mero decimal que representa el c√≥digo de car√°cter en la posici√≥n pos</p> <p>String.fromCodePoint(code)</p> <p>Crea un car√°cter por su c√≥digo num√©rico</p> <pre><code>console.log('a' &gt; 'z'); // faslse\n\nconsole.log(\"z\".codePointAt(0)); // 122\n\nconsole.log(String.fromCodePoint(90)); // Z\nconsole.log(String.fromCodePoint(0x5a)); // Se puede pasar en hexadecimal tambi√©n\n</code></pre> <p>Comparar strings correctamente es complejo porque cada idioma tiene su propio alfabeto y reglas. Letras que parecen iguales pueden ocupar posiciones distintas seg√∫n el lenguaje.</p> <p>Para resolver esto, los navegadores modernos implementan el est√°ndar ECMA 402, que permite comparaciones internacionalizadas.</p> <p><code>str.localeCompare(str2)</code> Este m√©todo compara dos strings seg√∫n las reglas del idioma y devuelve:</p> <ul> <li><code>1</code> ‚Üí <code>str</code> es mayor que <code>str2</code></li> <li><code>-1</code> ‚Üí <code>str</code> es menor que <code>str2</code></li> <li><code>0</code> ‚Üí ambos strings son equivalentes</li> </ul>","path":["JavaScript","Standard Built-in Objects"],"tags":[]},{"location":"java-script/standard-built-in-objects/#numeros","level":2,"title":"N√∫meros","text":"<p>En JavaScript moderno, existen dos tipos principales de n√∫meros:</p> <ol> <li> <p>N√∫meros regulares: Almacenados en formato de 64 bits (IEEE-754), tambi√©n conocidos como n√∫meros de coma flotante de doble precisi√≥n. Son los que usamos la gran mayor√≠a del tiempo.</p> </li> <li> <p>BigInt: Utilizados para enteros que superan el l√≠mite seguro de ¬±(2‚Åµ¬≥-1).</p> </li> </ol> <p>A continuaci√≥n, nos centraremos en los n√∫meros regulares.</p> <p>Para facilitar la lectura de cifras grandes, JavaScript permite el uso de guiones bajos <code>_</code> como separadores visuales. El motor ignora estos caracteres.</p> <pre><code>const num = 1_000_000_000;\n</code></pre> <p>Tambi√©n podemos usar la notaci√≥n cient√≠fica a√±adiendo la letra \"e\". Esto multiplica el n√∫mero por 1 con la cantidad de ceros indicada despu√©s de la \"e\".</p> <pre><code>const num = 3e3; // 3 * 1000 = 3000\nconst decimalNum = 2.5e6; // 2.5 * 1000000 = 2500000\n</code></pre> <p>Para micro decimales, un n√∫mero negativo tras la \"e\" indica una divisi√≥n por 1 con esa cantidad de ceros.</p> <pre><code>const num = 1e-6; // 1 / 1000000 = 0.000001\n</code></pre> <p>Sistemas num√©ricos alternativos</p> <p>JavaScript soporta prefijos para escribir en otros sistemas adem√°s del decimal:</p> <ul> <li> <p>Hexadecimal (0x): Com√∫n para colores y bytes.</p> </li> <li> <p>Binario (0b):</p> </li> <li> <p>Octal (0o):</p> </li> </ul> <pre><code>const hex = 0xAF;      // 175\nconst binario = 0b101; // 5\nconst octal = 0o10;    // 8\n</code></pre> <p>Conversi√≥n a String con base: toString(base)</p> <p>El m√©todo num.toString(base) convierte un n√∫mero a su representaci√≥n en cadena en la base especificada (entre 2 y 36).</p> <pre><code>const n = 200;\nconsole.log(n.toString(16)); // \"c8\" (hexadecimal)\nconsole.log(n.toString(2));  // \"11001000\" (binario)\n</code></pre> <p>Nota sobre sintaxis: Si intentas llamar a este m√©todo directamente sobre un n√∫mero entero literal, debes usar dos puntos .. o par√©ntesis para evitar errores de sintaxis, ya que JS espera decimales tras el primer punto.</p> <pre><code>123..toString(36); // Correcto\n(123).toString(36); // Correcto\n</code></pre> <p>Redondeo</p> <p>Existen varias funciones en el objeto <code>Math</code> para tratar decimales:</p> M√©todo Descripci√≥n Ejemplo (Entrada 5.7) Ejemplo (Entrada -2.3) Math.floor Devuelve el entero mayor ‚â§ al n√∫mero (‚àí‚àû) 5 -3 Math.ceil Devuelve el entero menor ‚â• al n√∫mero (+‚àû) 6 -2 Math.round Al entero m√°s cercano 6 -2 Math.trunc Elimina los decimales (hacia 0) 5 -2 <p>Redondear a una precisi√≥n espec√≠fica</p> <p>Para redondear a n d√≠gitos (ej. moneda), tenemos dos estrategias:</p> <ol> <li> <p>Multiplicar y dividir: Desplazar la coma, redondear y restaurar.</p> </li> <li> <p>toFixed(n): Redondea y devuelve un string.</p> </li> </ol> <pre><code>const price = 15.6789;\nalert( Math.round(price * 100) / 100 ); // 15.6789 -&gt; 1567.89 -&gt; 15 -&gt; 15.67\n\n// M√©todo toFixed\nconsole.log(precio.toFixed(2)); // \"15.68\" (String)\n\n// Conversi√≥n a n√∫mero con +\nconsole.log(+precio.toFixed(2)); // 15.68 (Number)\n</code></pre> <p>Problemas de Precisi√≥n (IEEE-754)</p> <p>Debido a que los n√∫meros se guardan en formato binario de 64 bits, hay fracciones decimales simples (como 0.1) que son infinitas en binario. Esto causa p√©rdidas de precisi√≥n.</p> <pre><code>console.log(0.1 + 0.2 === 0.3); // false\nconsole.log(0.1 + 0.2); // 0.30000000000000004\n</code></pre> <p>Soluci√≥n: Usar toFixed para redondear el resultado o trabajar con enteros (ej. c√©ntimos en vez de euros) y dividir al final.</p> <p>Valores Especiales y Comprobaciones</p> <p>Infinity y NaN</p> <ul> <li> <p>Infinity: Ocurre al desbordar la capacidad de almacenamiento.</p> </li> <li> <p>NaN (Not a Number): Resultado de errores matem√°ticos. NaN es √∫nico porque no es igual a nada, ni siquiera a s√≠ mismo (NaN === NaN es false).</p> </li> </ul> <p>Funciones de validaci√≥n</p> <p>En un sentido, Number.isNaN y Number.isFinite son m√°s simples y directas que las funciones isNaN e isFinite. Pero en la pr√°ctica isNaN e isFinite son las m√°s usadas, porque son m√°s cortas.</p> <ol> <li> <p>isNaN(valor) vs Number.isNaN(valor):</p> <ul> <li> <p>isNaN convierte el valor a n√∫mero primero. isNaN(\"hola\") es true.</p> </li> <li> <p>Number.isNaN verifica que sea tipo number Y sea NaN. Number.isNaN(\"hola\") es false.</p> </li> </ul> </li> <li> <p>isFinite(valor) vs Number.isFinite(valor):</p> <ul> <li> <p>Verifica si un n√∫mero es regular (ni NaN, ni Infinity).</p> </li> <li> <p>Number.isFinite no realiza conversi√≥n de tipos impl√≠cita.</p> </li> </ul> </li> <li> <p>Number.isInteger(valor):</p> <ul> <li>Comprueba si un n√∫mero es entero.</li> </ul> </li> </ol> <p>Resumen:</p> <ul> <li>isNaN = \"¬øEsto se convierte en un error matem√°tico?\"</li> <li>Number.isNaN = \"¬øEs esto el valor espec√≠fico de error matem√°tico?\"</li> </ul> <p>Object.is</p> <p>Funciona como === pero maneja correctamente dos casos borde:</p> <ul> <li> <p>Object.is(NaN, NaN) === true</p> </li> <li> <p>Object.is(0, -0) === false</p> </li> </ul> <p>Parseo de N√∫meros (Lectura \"suave\")</p> <p>A diferencia de Number() o el unario + que son estrictos, parseInt y parseFloat leen una cadena hasta que encuentran un car√°cter no num√©rico y devuelven lo le√≠do.</p> <pre><code>console.log(parseInt(\"150px\")); // 150\nconsole.log(parseFloat(\"12.5em\")); // 12.5\nconsole.log(parseInt(\"a123\")); // NaN (falla si el primer car√°cter no es num√©rico)\n</code></pre> <p>parseInt acepta un segundo argumento para la base (radix), √∫til para hex o binario:</p> <pre><code>console.log(parseInt(\"ff\", 16)); // 255\n</code></pre> <p>Objeto Math</p> <p>Contiene funciones matem√°ticas y constantes.</p> <ul> <li> <p>Math.random(): Aleatorio entre 0 y 1 (excluyendo el 1).</p> </li> <li> <p>Math.max(a, b...) / Math.min(a, b...): Devuelve el mayor/menor argumento.</p> </li> <li> <p>Math.pow(n, p): Eleva n a la potencia p.</p> </li> </ul>","path":["JavaScript","Standard Built-in Objects"],"tags":[]},{"location":"java-script/standard-built-in-objects/#arrays","level":2,"title":"Arrays","text":"<p>Los objetos son excelentes para guardar datos etiquetados (clave-valor), pero cuando necesitamos orden (primero, segundo, tercero...), los objetos se quedan cortos.</p> <p>Para colecciones ordenadas existe el Array (tambi√©n llamado matriz, arreglo o vector).</p>","path":["JavaScript","Standard Built-in Objects"],"tags":[]},{"location":"java-script/standard-built-in-objects/#creacion-de-arrays","level":3,"title":"Creaci√≥n de Arrays","text":"<p>Existen dos formas, aunque la segunda es la est√°ndar:</p> <pre><code>// 1. Sintaxis literal (La m√°s usada)\nconst fruits = [\"Manzana\", \"Naranja\", \"Pera\"]; \nconst emptyFruit = [];\n\n// 2. Constructor (Rara vez se usa)\nconst emptyArray = new Array();\n</code></pre> <p>Array.isArray(valor): La √∫nica forma fiable de saber si algo es un array (porque typeof [] da object).</p>","path":["JavaScript","Standard Built-in Objects"],"tags":[]},{"location":"java-script/standard-built-in-objects/#acceso-y-modificacion","level":3,"title":"Acceso y Modificaci√≥n","text":"<p>Los elementos se enumeran comenzando desde el √≠ndice 0.</p> <pre><code>const data = [\"Hola\", \"Mundo\"];\n\n// Leer\nconsole.log(data[0]); // \"Hola\"\n\n// Modificar\ndata[1] = \"Javascript\"; // [\"Hola\", \"Javascript\"]\n\n// A√±adir nuevo √≠ndice\ndata[2] = \"Adios\"; // [\"Hola\", \"Javascript\", \"Adios\"]\n\n// Longitud\nconsole.log(data.length); // 3\n</code></pre> <p>Un array puede mezclar tipos de datos (strings, n√∫meros, objetos, funciones...).</p>","path":["JavaScript","Standard Built-in Objects"],"tags":[]},{"location":"java-script/standard-built-in-objects/#acceso-al-ultimo-elemento-at","level":4,"title":"Acceso al √∫ltimo elemento (at)","text":"<p>Tradicionalmente se usaba <code>arr[arr.length - 1]</code>. Ahora podemos usar el m√©todo <code>.at()</code> que acepta √≠ndices negativos para contar desde el final.</p> <pre><code>let lista = [\"A\", \"B\", \"C\"];\n\nconsole.log(lista[lista.length - 1]); // \"C\" (Cl√°sico)\nconsole.log(lista.at(-1));            // \"C\" (Moderno y limpio)\n</code></pre>","path":["JavaScript","Standard Built-in Objects"],"tags":[]},{"location":"java-script/standard-built-in-objects/#colas-y-pilas-metodos-basicos","level":3,"title":"Colas y Pilas (M√©todos b√°sicos)","text":"<p>Los arrays en JS funcionan como Deque (Double-ended queue), permitiendo operar eficientemente en ambos extremos.</p> <p>Final del Array (Muy r√°pidos)</p> <ul> <li> <p>push(...items): A√±ade al final.</p> </li> <li> <p>pop(): Extrae y devuelve el √∫ltimo elemento.</p> </li> </ul> <pre><code>const stack = [\"Plato 1\"];\nstack.push(\"Plato 2\"); // [\"Plato 1\", \"Plato 2\"]\nconst last = stack.pop(); // Devuelve \"Plato 2\" y el array queda [\"Plato 1\"]\n</code></pre> <p>Principio del Array (M√°s lentos)</p> <p>Son m√°s lentos porque al quitar/poner el primero, el motor debe renumerar todos los √≠ndices siguientes (el 1 pasa a ser 0, el 2 a ser 1, etc.).</p> <ul> <li>shift(): Extrae y devuelve el primer elemento.</li> <li>unshift(...items): A√±ade al principio.</li> </ul> <pre><code>const queue = [\"Cliente 1\", \"Cliente 2\"];\nconst firstClient = queue.shift(); // Saca \"Cliente 1\". Queda [\"Cliente 2\"]\nqueue.unshift(\"Cliente VIP\"); // Queda [\"Cliente VIP\", \"Cliente 2\"]\n</code></pre> <p>Puntos en com√∫n</p> <ul> <li> <p>shift y pop, devuelven el elemento eliminando, y solo eliminan de uno en uno.</p> </li> <li> <p>unshift y push, devuelven la nueva length del array, y pueden agregar varios argumentos a la vez.</p> </li> </ul>","path":["JavaScript","Standard Built-in Objects"],"tags":[]},{"location":"java-script/standard-built-in-objects/#busqueda","level":3,"title":"B√∫squeda","text":"<p><code>indexOf(item, fromIndex)</code></p> <p>Busca un elemento comenzando desde el principio (izquierda a derecha) y te dice d√≥nde est√°.</p> <ul> <li> <p>¬øQu√© devuelve? El √≠ndice (n√∫mero) de la primera vez que aparece el elemento.</p> </li> <li> <p>¬øSi no est√°? Devuelve <code>-1</code>.</p> </li> <li> <p>Comparaci√≥n: Usa igualdad estricta (<code>===</code>).</p> </li> </ul> <pre><code>const fruits = ['Manzana', 'Pera', 'Manzana', 'Uva'];\n\nconsole.log(fruits.indexOf('Pera'));    // 1\nconsole.log(fruits.indexOf('Manzana')); // 0 (Solo devuelve la primera que encuentra)\nconsole.log(fruits.indexOf('Mel√≥n'));   // -1 (No existe)\n</code></pre> <p>El segundo par√°metro (fromIndex): Puedes decirle desde qu√© √≠ndice empezar a buscar.</p> <pre><code>// Buscar 'Manzana' pero empezando a mirar desde el √≠ndice 1\nconsole.log(fruits.indexOf('Manzana', 1)); // 2\n</code></pre> <p><code>lastIndexOf(item, fromIndex)</code></p> <p>Funciona igual que indexOf, pero busca de derecha a izquierda (empieza por el final del array).</p> <p><code>includes(item, fromIndex)</code></p> <p>Es la versi√≥n moderna (ES2016). En lugar de decirte la posici√≥n, te dice si existe o no.</p> <ul> <li> <p>¬øQu√© devuelve? Un booleano: true o false.</p> </li> <li> <p>Ventaja clave: Es el √∫nico m√©todo que puede encontrar NaN.</p> </li> </ul> <p><code>find(funcion)</code></p> <p>Recorre el array y ejecuta la funci√≥n para cada elemento hasta que uno devuelva <code>true</code>.</p> <ul> <li>Devuelve: El primer elemento (el valor en s√≠) que cumpla la condici√≥n.</li> <li>Si no encuentra nada: Devuelve <code>undefined</code>.</li> </ul> <pre><code>const inventario = [\n    { nombre: \"Manzanas\", cantidad: 2 },\n    { nombre: \"Pl√°tanos\", cantidad: 0 },\n    { nombre: \"Cerezas\", cantidad: 5 }\n];\n\n// Queremos encontrar el primer objeto que tenga cantidad 0\nconst resultado = inventario.find(fruta =&gt; fruta.cantidad === 0);\n\nconsole.log(resultado); \n// Resultado: { nombre: \"Pl√°tanos\", cantidad: 0 }\n</code></pre> <p><code>findIndex(funcion)</code></p> <p>Hace exactamente la misma b√∫squeda que <code>find</code>, pero le interesa la posici√≥n.</p> <ul> <li> <p>Devuelve: El √≠ndice (n√∫mero) del primer elemento que cumpla la condici√≥n.</p> </li> <li> <p>Si no encuentra nada: Devuelve <code>-1</code>.</p> </li> </ul> <pre><code>const numeros = [5, 12, 8, 130, 44];\n\n// Queremos saber la POSICI√ìN del primer n√∫mero mayor que 100\nconst indice = numeros.findIndex(num =&gt; num &gt; 100);\n\nconsole.log(indice); \n// Resultado: 3 (Porque el 130 est√° en el √≠ndice 3)\n</code></pre>","path":["JavaScript","Standard Built-in Objects"],"tags":[]},{"location":"java-script/standard-built-in-objects/#transformar-y-reordenar","level":3,"title":"Transformar y reordenar","text":"<p><code>map(funcion)</code></p> <p>Se utiliza cuando quieres transformar cada elemento de un array.</p> <ul> <li> <p>Entrada: Un array de longitud N.</p> </li> <li> <p>Salida: Un NUEVO array de la MISMA longitud N, con los elementos modificados.</p> </li> <li> <p>Analog√≠a: Una f√°brica. Entra materia prima (metal), la m√°quina la procesa, y salen piezas terminadas.</p> </li> </ul> <pre><code>const numeros = [1, 2, 3, 4];\n\n// Queremos el doble de cada n√∫mero\nconst dobles = numeros.map(num =&gt; num * 2);\n\nconsole.log(numeros); // [1, 2, 3, 4] (Original intacto)\nconsole.log(dobles);  // [2, 4, 6, 8] (Nuevo array transformado)\n</code></pre> <p><code>filter(funcion)</code></p> <p>Se utiliza cuando quieres seleccionar un subconjunto de elementos.</p> <ul> <li> <p>Entrada: Un array de longitud N.</p> </li> <li> <p>Salida: Un NUEVO array de longitud igual o menor a N.</p> </li> <li> <p>Funcionamiento: La funci√≥n debe devolver true (se queda) o false (se va).</p> </li> </ul> <pre><code>const precios = [100, 50, 200, 30];\n\n// Queremos solo los precios baratos (menores de 80)\nconst baratos = precios.filter(precio =&gt; precio &lt; 80);\n\nconsole.log(baratos); // [50, 30]\n</code></pre> <p><code>reduce(funcion, valorInicial)</code></p> <p>Se utiliza para reducir todo el array a un √∫nico valor (aunque ese valor puede ser un n√∫mero, un objeto, o incluso otro array).</p> <p>Entrada: Un array. Salida: Un √∫nico valor acumulado.</p> <p>Argumentos</p> <ul> <li>acumulador: El resultado de la vuelta anterior.</li> <li>actual: El elemento que estamos recorriendo ahora.</li> </ul> <pre><code>arr.reduce((acumulador, actual) =&gt; acumulador + actual, valorInicial);\n\nconst numeros = [10, 20, 30];\n\nconst total = numeros.reduce((acumulador, numeroActual) =&gt; {\n    return acumulador + numeroActual;\n}, 0); // &lt;--- El 0 es el valor inicial del acumulador\n\nconsole.log(total); // 60\n</code></pre> <p><code>split(separador)</code></p> <p>Este m√©todo divide un objeto de tipo String en un array de cadenas mediante la separaci√≥n de la cadena en subcadenas.</p> <ul> <li> <p>M√©todo de: String.</p> </li> <li> <p>Devuelve: Un Nuevo Array.</p> </li> </ul> <pre><code>const frase = \"Hola-mundo-cruel\";\n\n// 1. Separar por un car√°cter espec√≠fico (gui√≥n)\n// Elimina el separador y crea elementos nuevos\nconst palabras = frase.split(\"-\");\nconsole.log(palabras); // [\"Hola\", \"mundo\", \"cruel\"]\n\n// 2. Separar por espacios (t√≠pico para contar palabras)\nconst texto = \"Aprender JavaScript es divertido\";\nconst arrayPalabras = texto.split(\" \");\nconsole.log(arrayPalabras); // [\"Aprender\", \"JavaScript\", \"es\", \"divertido\"]\n\n// 3. Separar letra por letra (String vac√≠o)\n// Muy √∫til para manipular caracteres individualmente\nconst letras = \"Hola\".split(\"\");\nconsole.log(letras); // [\"H\", \"o\", \"l\", \"a\"]\n</code></pre> <p><code>join(uni√≥n)</code></p> <p>Une todos los elementos de un array (o un objeto similar a un array) en una cadena y devuelve esta cadena.</p> <ul> <li> <p>M√©todo de: Array.</p> </li> <li> <p>Devuelve: Un String.</p> </li> </ul> <pre><code>const tecnologias = [\"HTML\", \"CSS\", \"JS\"];\n\n// 1. Unir con un separador visual\nconsole.log(tecnologias.join(\" / \")); // \"HTML / CSS / JS\"\n\n// 2. Unir sin nada (pegado total)\nconsole.log(tecnologias.join(\"\")); // \"HTMLCSSJS\"\n\n// 3. Por defecto (sin argumentos)\n// Si no le pasas nada, JS usa una coma autom√°ticamente\nconsole.log(tecnologias.join()); // \"HTML,CSS,JS\"\n</code></pre> <p><code>sort(funcionComparadora)</code></p> <p>Ordena los elementos de un array localmente y devuelve el array ordenado.</p> <p>‚ö†Ô∏è El gran peligro de sort() por defecto Si usas sort() sin argumentos, JavaScript convierte cada elemento a String y compara sus c√≥digos UTF-16 (orden alfab√©tico/lexicogr√°fico).</p> <p>Esto es un desastre para los n√∫meros:</p> <pre><code>const numeros = [1, 5, 10, 2, 25];\n\n// ERROR COM√öN:\nnumeros.sort();\nconsole.log(numeros); \n// Resultado: [1, 10, 2, 25, 5] \n// ¬øPor qu√©? Porque el texto \"10\" va antes que \"2\" alfab√©ticamente.\n</code></pre> <p>‚úÖ La Soluci√≥n: La Funci√≥n de Comparaci√≥n Para ordenar n√∫meros correctamente, debemos pasarle una funci√≥n que tome dos valores (a y b) y devuelva un n√∫mero:</p> <ul> <li> <p>Si devuelve negativo: a va antes que b.</p> </li> <li> <p>Si devuelve positivo: b va antes que a.</p> </li> <li> <p>Si devuelve cero: Se quedan igual.</p> </li> </ul> <p>F√≥rmulas M√°gicas:</p> <pre><code>const precios = [1, 5, 10, 2, 25];\n\n// Orden Ascendente (Menor a Mayor): a - b\nprecios.sort((a, b) =&gt; a - b); \nconsole.log(precios); // [1, 2, 5, 10, 25]\n\n// Orden Descendente (Mayor a Menor): b - a\nprecios.sort((a, b) =&gt; b - a);\nconsole.log(precios); // [25, 10, 5, 2, 1]\n</code></pre> <p><code>reverse()</code></p> <p>Invierte el orden de los elementos del array \"in-place\" (en el mismo sitio). El primero pasa a ser el √∫ltimo, y viceversa.</p> <ul> <li>Devuelve: El mismo array (la referencia al original), ya invertido.</li> </ul> <pre><code>const cuentaAtras = [1, 2, 3, 4, 5];\n\ncuentaAtras.reverse();\n\nconsole.log(cuentaAtras); // [5, 4, 3, 2, 1] (El original ha cambiado)\n</code></pre>","path":["JavaScript","Standard Built-in Objects"],"tags":[]},{"location":"java-script/standard-built-in-objects/#some-y-every","level":3,"title":"Some y Every","text":"<p><code>some(funcion)</code></p> <p>Comprueba si al menos un elemento del array cumple la condici√≥n.</p> <ul> <li>Funcionamiento: Recorre el array y se detiene en cuanto encuentra el primer <code>true</code>.</li> <li>Analog√≠a: El operador OR (<code>||</code>). \"¬øHay alg√∫n m√©dico en la sala?\". Con que uno levante la mano, la respuesta es S√ç (<code>true</code>).</li> </ul> <pre><code>const temperaturas = [-5, 10, 25, 8];\n\n// ¬øHay alguna temperatura bajo cero (helada)?\nconst hayHelada = temperaturas.some(temp =&gt; temp &lt; 0);\n\nconsole.log(hayHelada); \n// Resultado: true (Porque encontr√≥ el -5 y par√≥ de buscar)\n</code></pre> <p><code>every(funcion)</code></p> <p>Comprueba si todos y cada uno de los elementos cumplen la condici√≥n.</p> <ul> <li> <p>Funcionamiento: Recorre el array y se detiene en cuanto encuentra el primer false (un intruso).</p> </li> <li> <p>Analog√≠a: El operador AND (&amp;&amp;). \"¬øSois todos mayores de edad?\". Si uno solo dice \"tengo 15\", la respuesta global es NO (false).</p> </li> </ul> <pre><code>const notas = [10, 8, 9, 4];\n\n// ¬øHan aprobado TODOS los alumnos (nota &gt;= 5)?\nconst todosAprobados = notas.every(nota =&gt; nota &gt;= 5);\n\nconsole.log(todosAprobados); \n// Resultado: false (Fall√≥ al llegar al 4 y par√≥)\n</code></pre>","path":["JavaScript","Standard Built-in Objects"],"tags":[]},{"location":"java-script/standard-built-in-objects/#slice-y-splide","level":3,"title":"Slice y Splide","text":"<p><code>slice(inicio, final)</code></p> <p>Crea un nuevo array copiando una porci√≥n del original. El array original se queda intacto.</p> <ul> <li> <p>Significado: \"Rebanada\" o \"Trozo\".</p> </li> <li> <p>Par√°metros:</p> <ul> <li><code>inicio</code>: √çndice donde empieza el corte (incluido).</li> <li><code>final</code> (Opcional): √çndice donde termina el corte (NO incluido). Si no se pone, va hasta el final.</li> </ul> </li> </ul> <pre><code>const original = [\"a\", \"b\", \"c\", \"d\", \"e\"];\n\n// Copiar desde el √≠ndice 1 hasta el 3 (sin incluir el 3)\nconst copia = original.slice(1, 3);\n\nconsole.log(copia);    // [\"b\", \"c\"]  (El nuevo trozo)\nconsole.log(original); // [\"a\", \"b\", \"c\", \"d\", \"e\"] (INTACTO)\n</code></pre> <p>Trucos de slice:</p> <ul> <li> <p>Clonar un array: arr.slice() (sin argumentos) crea una copia superficial exacta.</p> </li> <li> <p>√öltimos elementos: arr.slice(-2) te da los dos √∫ltimos.</p> </li> </ul> <p><code>splice(inicio, cantidadBorrar, ...insertar)</code></p> <p>Este m√©todo es una \"navaja suiza\". Modifica el array original insertando, borrando o reemplazando elementos \"in-place\".</p> <p>Devuelve: Un array con los elementos eliminados (no el array modificado).</p> <p>A. Borrar elementos</p> <pre><code>const meses = [\"Ene\", \"Feb\", \"Mar\", \"Abr\"];\n\n// Desde √≠ndice 1, borra 1 elemento\nconst eliminados = meses.splice(1, 1);\n\nconsole.log(meses);      // [\"Ene\", \"Mar\", \"Abr\"] (¬°Cambi√≥!)\nconsole.log(eliminados); // [\"Feb\"] (Lo que sacamos)\n</code></pre> <p>B. Insertar elementos (sin borrar) Ponemos el segundo par√°metro (deleteCount) a 0.</p> <p><pre><code>const colores = [\"Rojo\", \"Azul\"];\n\n// En la posici√≥n 1, no borres nada, mete \"Verde\"\ncolores.splice(1, 0, \"Verde\");\n\nconsole.log(colores); // [\"Rojo\", \"Verde\", \"Azul\"]\n</code></pre> C. Reemplazar (Borrar e Insertar a la vez) <pre><code>const menu = [\"Hamburguesa\", \"Papas\", \"Soda\"];\n\n// En pos 1, borra 1 (\"Papas\") y mete \"Ensalada\"\nmenu.splice(1, 1, \"Ensalada\");\n\nconsole.log(menu); // [\"Hamburguesa\", \"Ensalada\", \"Soda\"]\n</code></pre></p>","path":["JavaScript","Standard Built-in Objects"],"tags":[]},{"location":"java-script/standard-built-in-objects/#for-each","level":2,"title":"For Each","text":"<p>El m√©todo <code>.forEach()</code> ejecuta una funci√≥n una vez por cada elemento de una colecci√≥n. </p> <p>Se puede utilizar en Arrays, sets y maps.</p> <p>üëâ No es para transformar datos, es para ejecutar acciones.</p> <p>Sintaxis b√°sica</p> <pre><code>array.forEach((elemento, indice, arrayCompleto) =&gt; {\n    // c√≥digo a ejecutar\n});\n</code></pre> <p>Par√°metros del callback:</p> <ul> <li> <p><code>elemento</code>: valor actual (el m√°s usado)</p> </li> <li> <p><code>indice</code>: posici√≥n (0, 1, 2‚Ä¶)</p> </li> <li> <p><code>arrayCompleto</code>: array original (poco usado)</p> </li> </ul> <p>Solo el elemento (caso m√°s com√∫n)</p> <pre><code>const frutas = [\"Manzana\", \"Pera\", \"Uva\"];\n\nfrutas.forEach(fruta =&gt; {\n    console.log(\"Me gusta la \" + fruta);\n});\n</code></pre> <p>Usando el √≠ndice</p> <pre><code>const ranking = [\"Oro\", \"Plata\", \"Bronce\"];\n\nranking.forEach((medalla, posicion) =&gt; {\n    console.log(`Puesto ${posicion + 1}: ${medalla}`);\n});\n</code></pre> <p>NO devuelve nada</p> <ul> <li> <p>Siempre devuelve <code>undefined</code></p> </li> <li> <p>No crea un array nuevo</p> </li> </ul> <pre><code>const nums = [1, 2, 3];\nconst resultado = nums.forEach(n =&gt; n * 2);\n\nconsole.log(resultado); // undefined\n\nüëâ Si necesitas un array nuevo ‚Üí usa `.map()`\n</code></pre> <p>NO se puede detener</p> <ul> <li> <p><code>break</code> y <code>continue</code> NO funcionan</p> </li> <li> <p>El m√©todo siempre recorre todo el array</p> </li> </ul> <pre><code>nums.forEach(n =&gt; {\n    if (n &gt; 2) {\n        return; // solo salta esta iteraci√≥n\n    }\n    console.log(n);\n});\n</code></pre> <p>Uso en <code>Map</code> y <code>Set</code></p> <ul> <li>Map: <code>(valor, clave, map)</code></li> <li>Set: <code>(valor, valor, set)</code></li> </ul> <p>Comparativa r√°pida: <code>forEach</code> vs <code>map</code></p> Caracter√≠stica forEach() map() Objetivo Ejecutar acciones Transformar datos Devuelve <code>undefined</code> Nuevo array Modifica original No (salvo que lo hagas) No Uso t√≠pico Logs, DOM, BD Crear arrays nuevos <p>Regla mental r√°pida</p> <ul> <li>Usa <code>map</code> ‚Üí cuando quieres otra lista</li> <li>Usa <code>forEach</code> ‚Üí cuando quieres hacer algo, no obtener algo</li> </ul>","path":["JavaScript","Standard Built-in Objects"],"tags":[]},{"location":"java-script/standard-built-in-objects/#maps-y-sets","level":2,"title":"Maps y Sets","text":"","path":["JavaScript","Standard Built-in Objects"],"tags":[]},{"location":"java-script/standard-built-in-objects/#maps","level":3,"title":"Maps","text":"<p><code>new Map()</code></p> <p>Explicaci√≥n:</p> <p>Es el constructor. Crea una nueva instancia de un objeto Map en memoria.</p> <ul> <li> <p>Si lo llamas sin argumentos <code>new Map()</code>, crea un mapa vac√≠o.</p> </li> <li> <p>Si le pasas un iterable (generalmente un array de arrays), lo usa para rellenar el mapa inicialmente. Cada sub-array debe tener exactamente dos elementos: <code>[clave, valor]</code>.</p> </li> </ul> <p>Ejemplo: <pre><code>// 1. Crear vac√≠o\nconst mapaVacio = new Map();\n\n// 2. Crear con datos iniciales (Array de Arrays)\nconst precios = new Map([\n    ['manzana', 1.5],  // Clave: 'manzana', Valor: 1.5\n    ['pera', 2.0],     // Clave: 'pera', Valor: 2.0\n    ['uva', 3.5]       // Clave: 'uva', Valor: 3.5\n]);\n\nconsole.log(precios); // Map(3) { 'manzana' =&gt; 1.5, 'pera' =&gt; 2, 'uva' =&gt; 3.5 }\n</code></pre></p> <p><code>map.set(clave, valor)</code> Explicaci√≥n:</p> <p>Este m√©todo agrega un nuevo par clave-valor al mapa.</p> <ul> <li> <p>Importante: Si la clave ya existe, el m√©todo sobrescribe el valor antiguo con el nuevo. No duplica la clave.</p> </li> <li> <p>Retorno: Devuelve el propio objeto Map actualizado. Esto permite el \"encadenamiento\" (chaining), es decir, llamar a varios <code>.set()</code> seguidos en la misma l√≠nea.</p> </li> </ul> <p>Ejemplo: <pre><code>const usuarios = new Map();\n\n// Agregar uno por uno\nusuarios.set('admin', 'Juan P√©rez');\nusuarios.set('invitado', 'Ana G√≥mez');\n\n// Sobreescribir (Actualizar valor)\nusuarios.set('admin', 'Juan ACTUALIZADO'); \n\n// Encadenamiento (Chaining)\nusuarios\n    .set(1, 'usuario numero uno')\n    .set(true, 'usuario activo');\n\nconsole.log(usuarios.get('admin')); // \"Juan ACTUALIZADO\"\nconsole.log(usuarios.get(1));       // \"usuario numero uno\"\n</code></pre></p> <p><code>map.get(clave)</code></p> <p>Explicaci√≥n:</p> <p>Recupera el valor almacenado asociado a una clave espec√≠fica.</p> <ul> <li> <p>Busca la clave usando el algoritmo SameValueZero (casi igual a <code>===</code>).</p> </li> <li> <p>Ojo: Si la clave no se encuentra, devuelve <code>undefined</code>. Esto puede ser ambiguo si t√∫ guardaste expl√≠citamente un <code>undefined</code> como valor, por lo que a veces es mejor usar <code>has()</code> antes.</p> </li> </ul> <p>Ejemplo: <pre><code>const inventario = new Map([\n    ['teclado', 50],\n    ['mouse', 25]\n]);\n\n// 1. Clave que existe\nconsole.log(inventario.get('teclado')); // 50\n\n// 2. Clave que NO existe\nconsole.log(inventario.get('monitor')); // undefined\n\n// ‚ö†Ô∏è Detalle t√©cnico con Objetos como clave:\nconst objClave = { id: 1 };\ninventario.set(objClave, 'Datos del objeto');\n\n// Tienes que usar LA MISMA referencia de memoria\nconsole.log(inventario.get(objClave)); // \"Datos del objeto\"\nconsole.log(inventario.get({ id: 1 })); // undefined (Parecen iguales, pero son objetos distintos en memoria)\n</code></pre></p> <p><code>map.has(clave)</code></p> <p>Explicaci√≥n:</p> <p>Verifica la existencia de una clave. Es la forma correcta de preguntar \"¬øEst√° esto en el mapa?\".</p> <ul> <li> <p>Devuelve un Booleano: <code>true</code> si la clave est√°, <code>false</code> si no.</p> </li> <li> <p>Es muy r√°pido (m√°s eficiente que buscar en un array).</p> </li> </ul> <p>Ejemplo:</p> <pre><code>const codigos = new Map([\n    ['ES', 'Espa√±a'],\n    ['MX', 'M√©xico']\n]);\n\nif (codigos.has('MX')) {\n    console.log(\"M√©xico est√° en la lista\");\n} else {\n    console.log(\"No encontrado\");\n}\n\nconsole.log(codigos.has('AR')); // false\n</code></pre> <p><code>map.delete(clave)</code></p> <p>Explicaci√≥n:</p> <p>Elimina el par clave-valor espec√≠fico del mapa.</p> <ul> <li> <p>Devuelve <code>true</code> si el elemento exist√≠a y fue borrado.</p> </li> <li> <p>Devuelve <code>false</code> si el elemento no exist√≠a (no hizo nada).</p> </li> </ul> <p>Ejemplo: <pre><code>const tareas = new Map([\n    [1, 'Comprar leche'],\n    [2, 'Pagar luz']\n]);\n\n// Intentamos borrar la tarea 1\nconst fueBorrado = tareas.delete(1); \n\nconsole.log(fueBorrado); // true (Lo borr√≥ exitosamente)\nconsole.log(tareas.has(1)); // false (Ya no existe)\n\n// Intentamos borrar algo que no existe\nconsole.log(tareas.delete(99)); // false\n</code></pre></p> <p><code>map.clear()</code></p> <p>Explicaci√≥n:</p> <p>Es el bot√≥n de \"Formatear\". Elimina todos los elementos del mapa de golpe.</p> <ul> <li> <p>No devuelve nada √∫til (<code>undefined</code>).</p> </li> <li> <p>El mapa queda vac√≠o (<code>size</code> pasa a ser 0), pero la variable <code>map</code> sigue existiendo y se puede volver a usar.</p> </li> </ul> <p>Ejemplo: <pre><code>const papelera = new Map([\n    ['archivo1', 'tesis.doc'],\n    ['archivo2', 'foto.jpg']\n]);\n\nconsole.log(papelera.size); // 2\n\npapelera.clear(); // ¬°BOOM! Todo fuera.\n\nconsole.log(papelera.size); // 0\nconsole.log(papelera);      // Map(0) {}\n</code></pre></p> <p>Propiedad <code>map.size</code></p> <p>Explicaci√≥n:</p> <p>Es una propiedad (no un m√©todo, por eso no lleva par√©ntesis <code>()</code>). Devuelve un n√∫mero entero que indica cu√°ntas entradas (pares clave-valor) tiene el mapa actualmente.</p> <ul> <li>Equivale al <code>.length</code> de los arrays, pero para Maps se llama <code>.size</code>.</li> </ul> <p>Ejemplo: <pre><code>const equipo = new Map();\n\nequipo.set('portero', 'Courtois');\nequipo.set('delantero', 'Vinicius');\n\nconsole.log(\"Jugadores en el mapa: \" + equipo.size); // Jugadores en el mapa: 2\n\nequipo.delete('portero');\n\nconsole.log(equipo.size); // 1\n</code></pre></p>","path":["JavaScript","Standard Built-in Objects"],"tags":[]},{"location":"java-script/standard-built-in-objects/#sets","level":3,"title":"Sets","text":"<p><code>new Set()</code></p> <p>Explicaci√≥n:</p> <p>Es el constructor. Crea una nueva instancia de un conjunto en memoria.</p> <ul> <li> <p>Si se llama sin argumentos <code>new Set()</code>, crea un conjunto vac√≠o.</p> </li> <li> <p>Si se le pasa un iterable (como un Array), lo usa para inicializar el set.</p> </li> <li> <p>Nota importante: Si el iterable original contiene duplicados, el constructor los elimina autom√°ticamente al crear el Set.</p> </li> </ul> <p>Ejemplo:</p> <pre><code>// 1. Crear vac√≠o\nconst vacio = new Set();\n\n// 2. Crear con datos (Filtrado autom√°tico de duplicados)\nconst numeros = new Set([1, 2, 2, 2, 3]);\n\nconsole.log(numeros); // Set(3) { 1, 2, 3 }\n</code></pre> <p><code>set.add(valor)</code></p> <p>Explicaci√≥n: Agrega un nuevo valor al conjunto.</p> <ul> <li> <p>Unicidad: Si el valor ya existe, el m√©todo no hace nada (ignora la petici√≥n para mantener la unicidad).</p> </li> <li> <p>Nota: Devuelve el propio objeto set, lo que permite el encadenamiento de llamadas.</p> </li> </ul> <p>Ejemplo:</p> <pre><code>const lista = new Set();\n\n// Encadenar m√∫ltiples add\nlista.add(\"A\").add(\"B\").add(\"C\");\n\n// Intentar agregar un duplicado (no pasa nada)\nlista.add(\"A\"); \n\nconsole.log(lista); // Set(3) { \"A\", \"B\", \"C\" }\n</code></pre> <p><code>set.delete(valor)</code></p> <p>Explicaci√≥n: Elimina el valor especificado del conjunto.</p> <p>Nota: Devuelve un booleano (<code>true</code> o <code>false</code>):</p> <ul> <li><code>true</code>: Si el valor exist√≠a y fue borrado.</li> <li><code>false</code>: Si el valor no exist√≠a (no hubo cambios).</li> </ul> <p>Ejemplo:</p> <pre><code>const frutas = new Set([\"Manzana\", \"Pera\"]);\n\nconst borrado = frutas.delete(\"Manzana\"); \nconsole.log(borrado); // true (Fue borrado)\n\nconst intento = frutas.delete(\"Pi√±a\");\nconsole.log(intento); // false (No exist√≠a)\n</code></pre> <p><code>set.has(valor)</code></p> <p>Explicaci√≥n: Comprueba si un valor existe dentro del set.</p> <p>Nota: Devuelve <code>true</code> si existe, <code>false</code> si no.</p> <p>Rendimiento: </p> <p>Es extremadamente r√°pido (complejidad O(1)) comparado con buscar en un array, gracias a su estructura hash interna.</p> <p>Ejemplo:</p> <pre><code>const ids = new Set([101, 102]);\n\nif (ids.has(101)) {\n    console.log(\"ID encontrado\");\n}\n\nconsole.log(ids.has(999)); // false\n</code></pre> <p><code>set.clear()</code></p> <p>Explicaci√≥n: </p> <p>Elimina todos los elementos del set de golpe, dej√°ndolo vac√≠o.</p> <p>Nota: </p> <p>No devuelve nada (<code>undefined</code>). La propiedad <code>.size</code> pasa a ser <code>0</code>.</p> <p>Ejemplo:</p> <pre><code>const datos = new Set([1, 2, 3]);\n\nconsole.log(datos.size); // 3\n\ndatos.clear();\n\nconsole.log(datos.size); // 0\n</code></pre> <p><code>Propiedad set.size</code></p> <p>Funciona igual que en Map</p>","path":["JavaScript","Standard Built-in Objects"],"tags":[]},{"location":"java-script/standard-built-in-objects/#metodos-de-iteracion","level":3,"title":"M√©todos de iteraci√≥n","text":"<p><code>.keys()</code></p> <ul> <li> <p>Map: Devuelve las claves reales (lo que usaste para guardar el dato).</p> </li> <li> <p>Set: Devuelve los valores. (Como no tiene claves, usa el valor como identificador).</p> </li> </ul> <p><code>.values()</code></p> <ul> <li> <p>Map: Devuelve los valores (el dato guardado).</p> </li> <li> <p>Set: Devuelve los valores (Exactamente lo mismo que <code>.keys()</code> en un Set).</p> </li> </ul> <p><code>.entries()</code></p> <ul> <li> <p>Map: Devuelve un array <code>[clave, valor]</code>.</p> </li> <li> <p>Set: Devuelve un array <code>[valor, valor]</code>.</p> <ul> <li>¬øPor qu√©? Por compatibilidad. Si tienes un c√≥digo gen√©rico que espera recibir parejas (dos argumentos), el Set duplica el valor para no romper ese c√≥digo.</li> </ul> </li> </ul> <p><code>.forEach((val, key, collection) =&gt; ...)</code></p> <ul> <li> <p>Map: La funci√≥n recibe <code>(valor, clave, mapa)</code>.</p> </li> <li> <p>Set: La funci√≥n recibe <code>(valor, valor, set)</code>.</p> <ul> <li>El segundo argumento se repite intencionalmente para imitar la firma del Map.</li> </ul> </li> </ul> <p>Diferencia en <code>for..of</code> (Bucle por defecto)</p> <p>Aunque tienen los mismos m√©todos, si los metes directamente en un <code>for..of</code> sin especificar m√©todo (iteraci√≥n por defecto), se comportan distinto:</p> <ul> <li> <p><code>for (let x of map)</code> -&gt; Itera sobre .entries() (Recibes <code>[clave, valor]</code>).</p> </li> <li> <p><code>for (let x of set)</code> -&gt; Itera sobre .values() (Recibes solo el <code>valor</code>).</p> </li> </ul> <p>Ejemplo 1: El curioso caso de <code>.entries()</code></p> <pre><code>const miMap = new Map([ ['user', 'Eduardo'] ]);\nconst miSet = new Set([ 'Eduardo' ]);\n\n// En Map: [Clave, Valor]\n// Obtenemos el primer elemento del iterador\nconsole.log(miMap.entries().next().value);\n// Resultado: ['user', 'Eduardo']\n\n// En Set: [Valor, Valor] (¬°Duplicado por compatibilidad!)\nconsole.log(miSet.entries().next().value);\n// Resultado: ['Eduardo', 'Eduardo']\n</code></pre> <p>Ejemplo 2: forEach (Compatibilidad)</p> <p>F√≠jate c√≥mo podemos usar la misma estructura de callback, aunque en el Set el segundo argumento sea redundante.</p> <pre><code>const mapa = new Map([['a', 10], ['b', 20]]);\nconst conjunto = new Set([10, 20]);\n\nconsole.log(\"--- Iterando MAP ---\");\nmap.forEach((valor, clave) =&gt; {\n    console.log(`Clave: ${clave}, Valor: ${valor}`);\n});\n// Salida:\n// Clave: a, Valor: 10\n// Clave: b, Valor: 20\n\nconsole.log(\"--- Iterando SET ---\");\nconjunto.forEach((valor, valorAgain) =&gt; {\n    console.log(`Clave (falsa): ${valorAgain}, Valor: ${valor}`);\n});\n// Salida:\n// Clave (falsa): 10, Valor: 10\n// Clave (falsa): 20, Valor: 20\n</code></pre> <p>Ejemplo 3: Iteraci√≥n por defecto (for..of) Aqu√≠ se ve la √∫nica diferencia real de uso directo.</p> <pre><code>const m = new Map([['x', 1]]);\nconst s = new Set(['x']);\n\n// Map devuelve arrays\nfor (let item of m) {\n    console.log(item); // ['x', 1]\n}\n\n// Set devuelve valores sueltos\nfor (let item of s) {\n    console.log(item); // 'x'\n}\n</code></pre>","path":["JavaScript","Standard Built-in Objects"],"tags":[]},{"location":"java-script/standard-built-in-objects/#objetos","level":2,"title":"Objetos","text":"<p>A diferencia de los maps, en los objetos debemos usar esta sintaxis para sacar, las claves, el valor o ambos.</p> <ul> <li> <p>Object.keys(obj) ‚Äì devuelve un array de propiedades.</p> </li> <li> <p>Object.values(obj) ‚Äì devuelve un array de valores.</p> </li> <li> <p>Object.entries(obj) ‚Äì devuelve un array de pares [propiedad, valor]</p> </li> </ul> Caracter√≠stica Map Objeto Sintaxis de llamada map.keys() Object.keys(obj) (no obj.keys()) Devuelve iterable Array ‚Äúreal‚Äù <ul> <li> <p>Object.fromEntries(iterable) - A partir de un array, crea un objeto.</p> </li> <li> <p>obj.hasOwnProperty(clave) - Eval√∫a si tiene una propiedad o no, es m√°s seguro que <code>in</code> (busca en toda la cadena de herencia) que tambi√©n sirve para eso.</p> </li> </ul> <p>Object.assign(destino, ...fuentes)</p> <p>Copia todas las propiedades de uno o m√°s objetos fuente al objeto destino.</p> <ul> <li> <p>Ojo: Modifica el primer objeto (destino).</p> </li> <li> <p>Nota: Hoy en d√≠a se usa m√°s el \"Spread Operator\" (...), pero assign sigue siendo √∫til.</p> </li> <li> <p>Uno de sus usos es la clonaci√≥n de objetos planos. Para clonaci√≥n anidada es mejor usar structuredClone, aunque tambi√©n falla en algunos casos y hay que recurrir a librer√≠as externas o a un c√≥digo personalizado.</p> </li> </ul> <p>const target = { a: 1 }; const source = { b: 2 };</p> <pre><code>const target = { a: 1 };\nconst source = { b: 2 };\n\nObject.assign(target, source);\n\nconsole.log(target); // { a: 1, b: 2 }\n</code></pre>","path":["JavaScript","Standard Built-in Objects"],"tags":[]},{"location":"java-script/teorical-fundations/","level":1,"title":"Fundamentos te√≥ricos del lenguaje","text":"","path":["JavaScript","Fundamentos te√≥ricos del lenguaje"],"tags":[]},{"location":"java-script/teorical-fundations/#use-strict","level":2,"title":"use strict","text":"<p>Definici√≥n: Directiva (cadena de texto) introducida en ES5 que fuerza al motor de JS a ejecutar el c√≥digo en \"Modo Estricto\".</p> <p>¬øPara qu√© sirve?</p> <p>Cambia la forma en que el motor procesa el c√≥digo: convierte \"errores silenciosos\" (malas pr√°cticas que JS perdonaba antes) en errores reales (Exceptions), oblig√°ndote a escribir c√≥digo m√°s seguro y optimizable.</p> <p>¬øCu√°ndo usarlo?</p> <p>Manual (Escribirlo expl√≠citamente):</p> <ul> <li>Es necesario ponerlo al principio de scripts \"cl√°sicos\" (legacy) o archivos <code>.js</code> simples que no usan el sistema de m√≥dulos moderno.</li> </ul> <p>Impl√≠cito (Ya viene activado):</p> <p>En el desarrollo moderno, raramente necesitas escribirlo porque ya es el comportamiento por defecto en:</p> <ol> <li> <p>M√≥dulos ES6: Cualquier archivo tratado como m√≥dulo (<code>import</code>/<code>export</code> o <code>&lt;script type=\"module\"&gt;</code>) es estricto autom√°ticamente.</p> </li> <li> <p>Clases: Todo el c√≥digo dentro del cuerpo de una <code>class { ... }</code> se ejecuta siempre en modo estricto.</p> </li> <li> <p>Herramientas Modernas: Si usas TypeScript, Babel, o bundlers (Webpack, Vite), estos suelen manejarlo autom√°ticamente.</p> </li> </ol> <p>Principales Cambios</p> <ol> <li>Proh√≠be variables globales accidentales: No puedes asignar valor a una variable que no hayas declarado (sin <code>let</code>, <code>const</code> o <code>var</code>).</li> <li>Seguridad en <code>this</code>: En funciones sueltas, <code>this</code> pasa a ser <code>undefined</code> en lugar de apuntar al objeto global (<code>window</code>), evitando modificar el entorno global por error.</li> <li>Bloqueo de duplicados: No permite par√°metros duplicados en funciones (ej. <code>function sum(a, a)</code>).</li> </ol> <pre><code>\"use strict\";\n\n// 1. Error: Variable no declarada\nmensaje = \"Hola\"; // ReferenceError: mensaje is not defined \n// (Sin strict, JS crear√≠a una variable global \"mensaje\" autom√°ticamente)\n\n// 2. Cambio en this\nfunction checkContext() {\n    console.log(this);\n}\ncheckContext(); // undefined (Sin strict, devolver√≠a 'window')\n</code></pre>","path":["JavaScript","Fundamentos te√≥ricos del lenguaje"],"tags":[]},{"location":"java-script/teorical-fundations/#inclusion-de-javascript-en-html","level":2,"title":"Inclusi√≥n de JavaScript en HTML","text":"<p>La filosof√≠a clave en programaci√≥n es la separaci√≥n de preocupaciones (separation of concern): HTML para la estructura, CSS para el estilo y JavaScript para el comportamiento din√°mico. Deben mantenerse en archivos separados.</p> <p>Existen varias maneras de incluir c√≥digo JavaScript en HTML, cada una con pros y contras:</p> M√©todo D√≥nde se coloca Comportamiento Uso Recomendado Inline Dentro de la etiqueta <code>&lt;script&gt;</code> en el HTML. Se ejecuta inmediatamente al ser le√≠do. No recomendado, viola la separaci√≥n de preocupaciones. Link en head <code>&lt;script src=\"archivo.js\"&gt;&lt;/script&gt;</code>. El navegador pausa el parsing del HTML, descarga y ejecuta el script de inmediato. Causa errores si el script necesita acceder a elementos del DOM que a√∫n no se han creado. Link al final del body <code>&lt;script src=\"archivo.js\"&gt;&lt;/script&gt;</code>. Garantiza que el script se ejecuta solo despu√©s de que todo el HTML se ha parseado y el DOM est√° listo. Soluciona errores de acceso al DOM, pero retrasa la interactividad si el script es pesado. Con async En <code>&lt;head&gt;</code>: <code>&lt;script async src=\"archivo.js\"&gt;&lt;/script&gt;</code>. Descarga en paralelo con el parsing del HTML, pero pausa el parsing para ejecuci√≥n inmediata al completarse la descarga. Scripts externos que no tienen dependencia del DOM (ej. analytics o chatbots). Con defer En <code>&lt;head&gt;</code>: <code>&lt;script defer src=\"archivo.js\"&gt;&lt;/script&gt;</code>. Descarga en paralelo con el parsing del HTML, pero pospone la ejecuci√≥n hasta que el parsing del HTML haya finalizado. Recomendado para la mayor√≠a de los scripts internos, ya que mejora la velocidad y garantiza la disponibilidad del DOM.","path":["JavaScript","Fundamentos te√≥ricos del lenguaje"],"tags":[]},{"location":"java-script/teorical-fundations/#fases-de-compilacion","level":2,"title":"Fases de Compilaci√≥n","text":"<p>Esta secci√≥n explica c√≥mo el motor procesa y ejecuta tu c√≥digo, y c√≥mo los navegadores modernos han difuminado la l√≠nea entre \"interpretado\" y \"compilado\".</p> <p>Antes de que ocurra cualquier acci√≥n, el motor (Engine) transforma tu c√≥digo fuente:</p> <ul> <li> <p>Tokenizing (Tokenizaci√≥n): El motor rompe tu c√≥digo en piezas individuales llamadas \"tokens\" (palabras clave let, operadores =, nombres variable).</p> </li> <li> <p>Parsing (An√°lisis): Organiza esos tokens en un √°rbol de estructura l√≥gica llamado AST (Abstract Syntax Tree). Aqu√≠ ocurre el chequeo de gram√°tica; si hay un error de sintaxis, el proceso se detiene antes de ejecutar nada.</p> </li> <li> <p>Code Generation: Convierte ese AST en c√≥digo ejecutable (Bytecode) para la m√°quina.</p> </li> </ul>","path":["JavaScript","Fundamentos te√≥ricos del lenguaje"],"tags":[]},{"location":"java-script/teorical-fundations/#ejecucion-hibrida-interpretacion-jit","level":3,"title":"Ejecuci√≥n H√≠brida: Interpretaci√≥n + JIT","text":"<p>Aunque cl√°sicamente se define a JS como un lenguaje interpretado (lee y ejecuta l√≠nea por l√≠nea, lo que permite ver errores parciales al instante), los motores modernos (como V8 en Chrome) utilizan una t√©cnica llamada JIT (Compilaci√≥n Justo a Tiempo) que lo hace comportarse en rendimiento casi como un lenguaje compilado.</p>","path":["JavaScript","Fundamentos te√≥ricos del lenguaje"],"tags":[]},{"location":"java-script/teorical-fundations/#como-funciona-este-proceso-magico","level":3,"title":"¬øC√≥mo funciona este proceso \"m√°gico\"?","text":"<ul> <li> <p>Inicio R√°pido (Int√©rprete): Al principio, el motor usa un int√©rprete (\"Ignition\" en V8) para ejecutar el Bytecode inmediatamente. Esto permite que la p√°gina cargue y arranque r√°pido sin esperar a compilar todo el programa.</p> </li> <li> <p>El Monitor (Profiler): Mientras el c√≥digo corre, un \"monitor\" observa qu√© partes se usan m√°s. Si detecta una funci√≥n que se ejecuta muchas veces (c√≥digo \"caliente\" o hot code), la marca.</p> </li> <li> <p>Compilaci√≥n y Optimizaci√≥n: El compilador (\"TurboFan\" en V8) toma esas partes marcadas y las recompila a c√≥digo m√°quina nativo altamente optimizado.</p> </li> <li> <p>Resultado: Obtienes la flexibilidad de un lenguaje interpretado (inicio inmediato, tipado din√°mico) con la velocidad de ejecuci√≥n de uno compilado (c√≥digo m√°quina directo al procesador) en las tareas repetitivas.</p> </li> </ul>","path":["JavaScript","Fundamentos te√≥ricos del lenguaje"],"tags":[]},{"location":"java-script/teorical-fundations/#la-arquitectura-de-javascript","level":2,"title":"LA ARQUITECTURA DE JAVASCRIPT","text":"<p>Para entender c√≥mo funciona JS, debemos dividir el proceso en dos grandes mundos:</p> <ol> <li> <p>El Motor de JS (V8): Quien lee y ejecuta el c√≥digo (Contextos, Stack, Memoria).</p> </li> <li> <p>El Entorno (Navegador): Quien proporciona herramientas extra y gestiona la asincron√≠a (Web APIs, Event Loop).</p> </li> </ol>","path":["JavaScript","Fundamentos te√≥ricos del lenguaje"],"tags":[]},{"location":"java-script/teorical-fundations/#el-motor-y-el-contexto-de-ejecucion","level":3,"title":"El Motor y el Contexto de Ejecuci√≥n","text":"<p>Cuando el motor recibe tu archivo, no empieza a ejecutar l√≠neas inmediatamente. Primero tiene que preparar el terreno.</p>","path":["JavaScript","Fundamentos te√≥ricos del lenguaje"],"tags":[]},{"location":"java-script/teorical-fundations/#1-execution-context-contexto-de-ejecucion","level":4,"title":"1. Execution Context (Contexto de Ejecuci√≥n)","text":"<p>Es el entorno f√≠sico, la \"caja\", donde se procesa y transforma el c√≥digo. Existen dos tipos:</p> <ul> <li> <p>GEC (Global Execution Context): Se crea una sola vez al arrancar el script. Es la base.</p> </li> <li> <p>FEC (Function Execution Context): Se crea una caja nueva cada vez que se invoca una funci√≥n.</p> </li> </ul>","path":["JavaScript","Fundamentos te√≥ricos del lenguaje"],"tags":[]},{"location":"java-script/teorical-fundations/#detalle-tecnico-funciones-estandar-vs-arrow-functions","level":4,"title":"üîé Detalle T√©cnico: Funciones Est√°ndar vs. Arrow Functions","text":"<ul> <li>Function (<code>function a() {}</code>): Genera un contexto \"pesado\". Crea su propio entorno l√©xico, su propio objeto <code>arguments</code> y, lo m√°s importante, define su propio valor de <code>this</code> (Binding).</li> <li>Arrow Function (<code>const a = () =&gt; {}</code>): Genera un contexto \"ligero\". NO crea su propio <code>this</code> ni <code>arguments</code>. Si usas <code>this</code> dentro de una arrow function, el motor no lo encuentra en esa caja y sale a buscarlo al contexto superior (Lexical <code>this</code>).</li> </ul>","path":["JavaScript","Fundamentos te√≥ricos del lenguaje"],"tags":[]},{"location":"java-script/teorical-fundations/#el-ciclo-de-vida","level":3,"title":"El Ciclo de Vida","text":"<p>Aqu√≠ es donde entra el Lexical Environment. Todo contexto pasa obligatoriamente por dos fases.</p>","path":["JavaScript","Fundamentos te√≥ricos del lenguaje"],"tags":[]},{"location":"java-script/teorical-fundations/#fase-a-la-fase-de-creacion","level":4,"title":"FASE A: La Fase de Creaci√≥n","text":"<p>El motor escanea el c√≥digo sin ejecutarlo. Aqu√≠ se construye la \"infraestructura\".</p> <p>En esta fase ocurren 3 cosas cr√≠ticas:</p> <ol> <li> <p>Creaci√≥n del Objeto Global: (<code>window</code> en navegadores).</p> </li> <li> <p>Creaci√≥n del <code>this</code>: Se decide a qu√© hace referencia <code>this</code>.</p> </li> <li> <p>SETUP DEL LEXICAL ENVIRONMENT (Entorno L√©xico):</p> <p>El motor crea un objeto interno (la memoria de este contexto). Este objeto tiene dos partes:</p> <ul> <li> <p>Parte 1: Environment Record (El Inventario): El motor busca todas las declaraciones.</p> <ul> <li> <p><code>function</code>: Se guarda la funci√≥n entera en memoria. (Por esto podemos usar funciones antes de declararlas).</p> </li> <li> <p><code>var</code>: Se reserva el espacio y se asigna <code>undefined</code>. (Esto es el Hoisting cl√°sico).</p> </li> <li> <p><code>let</code> / <code>const</code>: Se reserva el nombre en memoria pero se marca como \"Uninitialized\" (No inicializado). Esto crea la TDZ (Temporal Dead Zone). Si intentas acceder aqu√≠, el motor lanza un error porque la variable existe pero tiene el acceso bloqueado.</p> </li> </ul> </li> <li> <p>Parte 2: Outer Environment Reference (El Enlace):</p> <ul> <li>Se guarda una referencia (un puntero) al Lexical Environment del padre. Esto es lo que crea la Scope Chain.</li> </ul> </li> </ul> </li> </ol>","path":["JavaScript","Fundamentos te√≥ricos del lenguaje"],"tags":[]},{"location":"java-script/teorical-fundations/#fase-b-la-fase-de-ejecucion","level":4,"title":"FASE B: La Fase de Ejecuci√≥n","text":"<p>El motor vuelve al principio y recorre el c√≥digo l√≠nea por l√≠nea.</p> <ul> <li> <p>Asignaci√≥n de Variables: Aqu√≠ es donde la variable deja de ser <code>undefined</code>.</p> <ul> <li> <p>Ejemplo: <code>var a = 10;</code></p> </li> <li> <p>En Fase Creaci√≥n: <code>a</code> era <code>undefined</code>.</p> </li> <li> <p>En Fase Ejecuci√≥n: El motor busca <code>a</code> en el Environment Record y actualiza el valor a <code>10</code>.</p> </li> <li>Ejecuci√≥n de C√≥digo: Si encuentra una llamada a funci√≥n, pausa este contexto y crea uno nuevo (repitiendo Fase A y B para esa funci√≥n).</li> </ul> </li> </ul>","path":["JavaScript","Fundamentos te√≥ricos del lenguaje"],"tags":[]},{"location":"java-script/teorical-fundations/#call-stack","level":3,"title":"Call Stack","text":"<p>Es la estructura de datos que lleva el orden de ejecuci√≥n. Guarda \"Registros\" (Stack Frames).</p> <p>Cada vez que se crea un Contexto, se crea un Registro en la pila que contiene:</p> <ol> <li> <p>El nombre de la funci√≥n.</p> </li> <li> <p>La l√≠nea de c√≥digo actual.</p> </li> <li> <p>Una referencia al Lexical Environment que acabamos de crear.</p> </li> </ol> <p>Regla: LIFO (Last In, First Out). El √∫ltimo en entrar es el primero en salir.</p>","path":["JavaScript","Fundamentos te√≥ricos del lenguaje"],"tags":[]},{"location":"java-script/teorical-fundations/#scope-alcance-y-scope-chain","level":3,"title":"Scope (Alcance) y Scope Chain","text":"<p>El Scope no es un objeto f√≠sico, es la regla de visibilidad. El Lexical Environment es la implementaci√≥n f√≠sica de esa regla.</p> <ol> <li> <p>Scope Chain (La b√∫squeda):     Cuando el c√≥digo pide una variable (<code>console.log(x)</code>), el motor hace esto:</p> <ul> <li>Mira en el Environment Record actual. ¬øEst√°? √ösala.</li> <li>¬øNo est√°? Usa el puntero Outer Reference para subir al entorno del padre.</li> <li>¬øNo est√°? Sube al abuelo.</li> <li>Llega al Global. ¬øNo est√°? -&gt; <code>ReferenceError</code>.</li> </ul> </li> <li> <p>Scope de Bloque (La diferencia var vs let):</p> <ul> <li>Un bloque es <code>{ ... }</code> (if, for, switch).</li> <li><code>let</code> / <code>const</code>: Crean un nuevo Entorno L√©xico declarativo para ese bloque. Las variables mueren cuando cierra la llave <code>}</code>.</li> <li><code>var</code>: Ignora los bloques. Se guarda en el Entorno L√©xico de la Funci√≥n m√°s cercana (o el Global). Por eso \"contamina\" y se escapa de los <code>if</code>.</li> </ul> </li> </ol>","path":["JavaScript","Fundamentos te√≥ricos del lenguaje"],"tags":[]},{"location":"java-script/teorical-fundations/#event-loop","level":3,"title":"Event Loop","text":"<p>Javascript es Single Threaded (un solo hilo). Solo tiene una Call Stack. Si hacemos algo lento (como pedir datos a un servidor o esperar 5 segundos), la p√°gina se congelar√≠a.</p> <p>Para evitarlo, el navegador ayuda con componentes extra.</p>","path":["JavaScript","Fundamentos te√≥ricos del lenguaje"],"tags":[]},{"location":"java-script/teorical-fundations/#1-los-componentes","level":4,"title":"1. Los Componentes","text":"<ul> <li>Call Stack: Donde ocurre el JS s√≠ncrono.</li> <li>Web APIs: Herramientas del navegador (<code>setTimeout</code>, <code>DOM</code>, <code>fetch</code>, <code>localStorage</code>). Trabajan en hilos separados (C++).</li> <li>Colas (Queues): Salas de espera.<ul> <li>Microtask Queue (VIP): Aqu√≠ van las Promesas (<code>.then</code>) y <code>MutationObserver</code>.</li> <li>Task Queue (Macrotask): Aqu√≠ van los <code>setTimeout</code>, <code>setInterval</code>, eventos DOM (<code>click</code>).</li> </ul> </li> </ul>","path":["JavaScript","Fundamentos te√≥ricos del lenguaje"],"tags":[]},{"location":"java-script/teorical-fundations/#2-el-render-pipeline-la-pantalla","level":4,"title":"2. El Render Pipeline (La Pantalla)","text":"<p>Coordinaci√≥n del Event Loop con la Pantalla</p> <p>El Event Loop no solo maneja tareas y microtareas; tiene que coordinarse con la pantalla. Tu pantalla se refresca (normalmente) 60 veces por segundo. Eso significa que el navegador tiene una ventana de 16.6 milisegundos para hacer todo.</p> <p>El Render Pipeline (Tuber√≠a de Renderizado)</p> <p>Es el proceso que ocurre cuando hay cambios visuales. Pasos detallados:</p> <ol> <li> <p>JavaScript: Se ejecuta tu c√≥digo (ej. cambiar una clase, a√±adir un elemento).</p> </li> <li> <p>Style (C√°lculo de Estilos): El navegador recalcula qu√© reglas CSS aplican a cada elemento (CSSOM).</p> </li> <li> <p>Layout (Reflow/Geometr√≠a): El paso m√°s costoso. Calcula cu√°nto mide y d√≥nde est√° cada caja (div, bot√≥n) en p√≠xeles. \"Este div mide 200x200 y est√° en la posici√≥n (10, 50)\".</p> </li> <li> <p>Paint (Pintura): Rellena los p√≠xeles. Colores, fondos, textos, sombras, bordes.</p> </li> <li> <p>Composite (Composici√≥n): Si hay capas (z-index, transformaciones 3D), el navegador las aplasta en una sola imagen final para la pantalla.</p> </li> </ol> <p>El Event Loop es un guardia de tr√°fico inteligente:</p> <ol> <li> <p>Ejecuta TODO el Javascript s√≠ncrono (Call Stack).</p> </li> <li> <p>Ejecuta TODAS las Microtareas (Promesas).</p> </li> <li> <p>MOMENTO DE DECISI√ìN: El Event Loop mira el reloj.</p> <ul> <li>¬øHan pasado 16ms? ¬øHay cambios visuales pendientes?</li> <li>S√ç: Ejecuta el Render Pipeline (Style -&gt; Layout -&gt; Paint).</li> <li>NO: Se salta el renderizado para ahorrar energ√≠a.</li> </ul> </li> <li> <p>Ejecuta UNA Macrotarea (setTimeout).</p> </li> <li> <p>Vuelve a empezar.</p> </li> </ol> <p>Conclusi√≥n: Por eso <code>setTimeout(..., 0)</code> no es inmediato. Tiene que esperar a que el JS acabe, las microtareas acaben, y posiblemente a que el navegador decida si necesita pintar la pantalla antes.</p>","path":["JavaScript","Fundamentos te√≥ricos del lenguaje"],"tags":[]},{"location":"java-script/teorical-fundations/#3-la-logica-del-event-loop-el-bucle-infinito","level":4,"title":"3. La L√≥gica del Event Loop (El Bucle Infinito)","text":"<p>El Event Loop es un algoritmo que gira constantemente haciendo estas comprobaciones estrictas:</p> <ol> <li> <p>¬øHay algo en la Call Stack?</p> <ul> <li>S√ç: ¬°Espera! No hagas nada m√°s. Deja que el JS acabe.</li> <li>NO: (El Stack est√° vac√≠o). Contin√∫a.</li> </ul> </li> <li> <p>¬øHay algo en la Microtask Queue? (Prioridad Absoluta)</p> <ul> <li>S√ç: Mueve la primera microtarea al Stack. Ejec√∫tala. Repite hasta que la cola de microtareas est√© VAC√çA (Si una microtarea crea otra, tambi√©n se ejecuta ahora).</li> <li>NO: Contin√∫a.</li> </ul> </li> <li> <p>Oportunidad de Renderizado (Render Pipeline):</p> <ul> <li>El navegador decide: \"¬øEs necesario pintar? ¬øHan pasado 16ms? ¬øHay cambios visuales?\"</li> <li>S√ç: Ejecuta Style -&gt; Layout -&gt; Paint.</li> <li>NO: Se salta este paso.</li> </ul> </li> <li> <p>¬øHay algo en la Task Queue (Macrotareas)?</p> <ul> <li>S√ç: Toma SOLAMENTE UNA tarea (la m√°s antigua). Mu√©vela al Call Stack. Ejec√∫tala.</li> <li>(Nota: A diferencia de las microtareas, no vac√≠a toda la cola de golpe. Hace una y vuelve a empezar el ciclo).</li> </ul> </li> </ol>","path":["JavaScript","Fundamentos te√≥ricos del lenguaje"],"tags":[]},{"location":"java-script/teorical-fundations/#el-ejemplo-completo","level":3,"title":"EL EJEMPLO COMPLETO","text":"<p>Vamos a analizar un c√≥digo que usa todo lo explicado.</p> <pre><code>// --- [GLOBAL CONTEXT - FASE CREACI√ìN] ---\n// 1. Lexical Env Global:\n//    - Record: { \n//        titulo: undefined (var), \n//        config: &lt;uninitialized&gt; (let),\n//        iniciar: &lt;function ref&gt;\n//      }\n//    - Outer: null\n\nconsole.log(\"1. Inicio\"); \n\nvar titulo = \"Demo JS\";       // Asignaci√≥n (Fase Ejecuci√≥n)\nlet config = { delay: 0 };    // Inicializaci√≥n (Fin TDZ)\n\n// Arrow function (No crea 'this', usa el Global)\nconst procesar = () =&gt; {\n    // Scope Chain: Busca 'titulo'. No est√° en procesar -&gt; Sube a Global.\n    console.log(\"4. Procesando: \" + titulo); \n\n    // MICROTAREA (Promesa)\n    Promise.resolve().then(() =&gt; {\n        console.log(\"5. Microtarea (Promesa)\");\n        titulo = \"Demo Finalizada\"; // Cambia variable global\n    });\n\n    // RENDER: Cambio visual\n    document.body.style.background = 'blue'; \n};\n\nfunction iniciar() {\n    // --- [INICIAR CONTEXT - FASE CREACI√ìN] ---\n    // 1. Lexical Env Iniciar:\n    //    - Record: { estado: undefined }\n    //    - Outer: Global Lexical Env\n\n    var estado = \"Activo\"; // Asignaci√≥n\n\n    // MACROTAREA (setTimeout)\n    // Web API recibe el timer. Como es 0ms, lo manda a la Task Queue YA.\n    setTimeout(() =&gt; {\n        console.log(\"6. Macrotarea (Timeout)\");\n    }, 0);\n\n    procesar(); // Llamada s√≠ncrona\n\n    console.log(\"3. Fin de funci√≥n iniciar\");\n}\n\niniciar();\n\nconsole.log(\"2. Fin del Script Global\");\n</code></pre>","path":["JavaScript","Fundamentos te√≥ricos del lenguaje"],"tags":[]},{"location":"java-script/teorical-fundations/#la-narrativa-paso-a-paso","level":4,"title":"LA NARRATIVA PASO A PASO","text":"<ol> <li> <p>Fase Creaci√≥n Global:</p> <ul> <li>Se crea el contexto Global.</li> <li>Se crea el Lexical Environment. <code>titulo</code> es <code>undefined</code>. <code>config</code> est√° en zona muerta. <code>iniciar</code> est√° listo para usarse.</li> </ul> </li> <li> <p>Ejecuci√≥n S√≠ncrona (Call Stack):</p> <ul> <li><code>console.log(\"1. Inicio\")</code>.</li> <li><code>titulo</code> recibe valor \"Demo JS\".</li> <li><code>config</code> recibe el objeto.</li> <li>Llamada a <code>iniciar()</code>.</li> </ul> </li> <li> <p>Dentro de <code>iniciar</code>:</p> <ul> <li>Se crea Contexto y Entorno L√©xico de <code>iniciar</code>.</li> <li>SetTimeout: JS llama a la Web API. La Web API ve 0ms y mete el callback en la Task Queue (Macrotarea).</li> <li>Llamada a <code>procesar()</code>.</li> </ul> </li> <li> <p>Dentro de <code>procesar</code> (Arrow Function):</p> <ul> <li><code>console.log(\"4. Procesando: \" + titulo)</code>. (Us√≥ Scope Chain para leer <code>titulo</code>).</li> <li>Promesa: El callback (<code>.then</code>) se va directo a la Microtask Queue.</li> <li>Cambio DOM: <code>background = 'blue'</code>. El navegador marca una \"flag\" interna diciendo \"Necesito repintar la pantalla\".</li> <li><code>procesar</code> termina. Sale del Stack.</li> </ul> </li> <li> <p>Cierre de <code>iniciar</code> y Global:</p> <ul> <li><code>console.log(\"3. Fin de funci√≥n iniciar\")</code>.</li> <li><code>iniciar</code> termina. Sale del Stack.</li> <li><code>console.log(\"2. Fin del Script Global\")</code>.</li> <li>Global termina. Call Stack VAC√çA.</li> </ul> </li> <li> <p>El Event Loop toma el control:</p> <ul> <li> <p>Paso A (Microtareas):</p> <ul> <li>¬øHay microtareas? S√ç (La promesa).</li> <li>Mueve callback al Stack -&gt; <code>console.log(\"5. Microtarea\")</code>.</li> <li>Cambia <code>titulo</code> a \"Demo Finalizada\".</li> <li>¬øM√°s microtareas? NO.</li> </ul> </li> <li> <p>Paso B (Render Pipeline):</p> <ul> <li>El Event Loop ve la \"flag\" de repintado y que el stack est√° vac√≠o.</li> <li>Calcula estilos -&gt; Layout -&gt; Pinta el fondo azul. (El usuario ve el cambio ahora).</li> </ul> </li> <li> <p>Paso C (Macrotareas):</p> <ul> <li>¬øHay macrotareas? S√ç (El Timeout).</li> <li>Mueve callback al Stack -&gt; <code>console.log(\"6. Macrotarea\")</code>.</li> </ul> </li> </ul> </li> </ol> <p>Resultado final en consola:</p> <ol> <li> <p><code>Inicio</code></p> </li> <li> <p><code>Procesando: Demo JS</code></p> </li> <li> <p><code>Fin de funci√≥n iniciar</code></p> </li> <li> <p><code>Fin del Script Global</code></p> </li> <li> <p><code>Microtarea (Promesa)</code></p> </li> <li> <p><code>Macrotarea (Timeout)</code></p> </li> </ol>","path":["JavaScript","Fundamentos te√≥ricos del lenguaje"],"tags":[]},{"location":"java-script/teorical-fundations/#this","level":2,"title":"This","text":"<p>Definici√≥n: Referencia al contexto de ejecuci√≥n actual (qui√©n llama a la funci√≥n en ese momento), no al lugar donde se escribi√≥ el c√≥digo.</p> <ul> <li> <p>Contexto vs Scope: El Scope es est√°tico (d√≥nde escribes); <code>this</code> es din√°mico (c√≥mo invocas).</p> </li> <li> <p>Global Context:</p> <ul> <li>Sin strict: Navegador: <code>window</code> | Node: <code>global</code>.</li> <li>\"use strict\": En funciones sueltas, <code>this</code> es <code>undefined</code>. <pre><code>function show() { console.log(this); }\nshow(); // undefined (Strict Mode) vs window (Non-strict)\n</code></pre></li> </ul> </li> </ul> <p>Implicit Binding</p> <ul> <li> <p>Ocurre en m√©todos: <code>objeto.metodo()</code>.</p> </li> <li> <p>Regla: <code>this</code> apunta al objeto que est√° a la izquierda del punto.</p> </li> </ul> <pre><code>const user = {\n    name: \"Ana\",\n    greet() { console.log(this.name); }\n};\nuser.greet(); // \"Ana\" (this es user)\n</code></pre> <p>Explicit Binding (Control Manual)</p> <p>Asocia el <code>this</code> de forma expl√≠cita, al objeto pasado como argumento en los siguientes metodos.</p> <ul> <li> <p>.call(obj, args...): Ejecuta inmediatamente. Args separados por comas.</p> </li> <li> <p>.apply(obj, [args]): Ejecuta inmediatamente. Args en Array.</p> </li> <li> <p>.bind(obj): NO ejecuta. Devuelve una nueva funci√≥n atada permanentemente.</p> </li> </ul> <pre><code>const person = { name: \"Luis\" };\n\nfunction say(lang) {\n     console.log(`${lang}: ${this.name}`); \n}\n\nsay.call(person, \"ES\");      // \"ES: Luis\"\nsay.apply(person, [\"EN\"]);   // \"EN: Luis\"\nconst boundFn = say.bind(person);\nboundFn(\"FR\");               // \"FR: Luis\"\n</code></pre> <p>New Binding</p> <p>Al usar new, JS crea un objeto vac√≠o y asigna this a esa nueva instancia.</p> <pre><code>function Car(model) {\n    this.model = model; \n}\nconst myCar = new Car(\"Toyota\"); // this = nuevo objeto\n</code></pre> <p>Arrow Functions (Lexical Scope)</p> <p>Excepci√≥n: NO tienen this propio.</p> <p>Mec√°nica: Toman prestado el this de su entorno padre (donde fueron escritas).</p> <ul> <li>Fallo</li> </ul> <p><pre><code>const usuario = {\n    nombre: \"Carlos\",\n    // ‚ùå MAL: Arrow function como m√©todo directo\n    saludar: () =&gt; {\n        console.log(this.nombre); \n        console.log(this);\n    }\n};\n\nusuario.saludar(); \n// Salida 1: undefined (porque busca nombre en window)\n// Salida 2: Window { ... } (el objeto global)\n</code></pre> * Soluci√≥n (aunque se recomienda, no usar arrow function si vamos a necesitar un this)</p> <pre><code>const obj = {\n    name: \"Data\",\n    process: function() {\n        // Arrow function hereda 'this' de 'process' (que es 'obj')\n        setTimeout(() =&gt; console.log(this.name), 100); \n    }\n};\nobj.process(); // \"Data\" (Funciona gracias a la arrow)\n</code></pre>","path":["JavaScript","Fundamentos te√≥ricos del lenguaje"],"tags":[]},{"location":"sql/sqlite/","level":1,"title":"Definici√≥n de SQLite3","text":"<p>SQLite3 es un sistema de gesti√≥n de bases de datos relacionales (RDBMS) escrito en lenguaje C. A diferencia de otros sistemas populares como MySQL o PostgreSQL, SQLite no es un motor de base de datos cliente/servidor, sino que es integrado (embedded).</p> <p>En t√©rminos sencillos: Es una base de datos completa contenida en un √∫nico archivo, que no requiere instalaci√≥n de servidores ni configuraciones complejas.</p>","path":["SQL","Definici√≥n de SQLite3"],"tags":[]},{"location":"sql/sqlite/#caracteristicas-principales","level":2,"title":"Caracter√≠sticas Principales","text":"<p>üñ•Ô∏è Sin Servidor (Serverless) La mayor√≠a de las bases de datos requieren un proceso de servidor ejecut√°ndose en segundo plano. SQLite no.</p> <ul> <li>El motor de SQLite se integra directamente en la aplicaci√≥n que lo usa.</li> <li>No hay un proceso intermediario.</li> </ul> <p>üìÅ Archivo √önico Toda la base de datos (tablas, √≠ndices, datos y vistas) reside en un solo archivo en el disco (generalmente con extensi√≥n <code>.db</code> o <code>.sqlite</code>).</p> <ul> <li>Facilita enormemente la portabilidad</li> <li>Simplifica las copias de seguridad</li> </ul> <p>‚öôÔ∏è Configuraci√≥n Cero No necesitas:</p> <ul> <li>Crear cuentas de usuario</li> <li>Asignar permisos complejos</li> <li>Configurar puertos de red</li> </ul> <p>Es plug-and-play: üëâ si tienes acceso al archivo, tienes acceso a la base de datos.</p> <p>üîê Cumple con ACID Garantiza:</p> <ul> <li>Atomicidad</li> <li>Consistencia</li> <li>Aislamiento</li> <li>Durabilidad</li> </ul> <p>Las transacciones se procesan de manera confiable y segura frente a fallos del sistema o cortes de energ√≠a.</p> <p>Casos de Uso Comunes</p> <ul> <li> <p>üì± Aplicaciones M√≥viles   Est√°ndar en Android e iOS para guardar datos locales de las apps.</p> </li> <li> <p>üñ•Ô∏è Aplicaciones de Escritorio   Navegadores web y programas de software lo usan para gestionar configuraciones, historial y cach√©s.</p> </li> <li> <p>üåê Internet de las Cosas (IoT)   Ideal para dispositivos peque√±os por su ligereza y bajo consumo de recursos.</p> </li> <li> <p>üß™ Desarrollo y Prototipado   Perfecto para fases iniciales de desarrollo o aprendizaje de SQL sin configurar servidores.</p> </li> <li> <p>üì¶ Formato de Archivo   Usado como formato eficiente para transferir conjuntos de datos entre sistemas.</p> </li> </ul> <p>Diferencias: SQLite3 vs. Motores Cliente-Servidor</p> Caracter√≠stica SQLite3 MySQL / PostgreSQL / Oracle Arquitectura Librer√≠a integrada en la aplicaci√≥n Cliente ‚Üî Servidor de red Almacenamiento Un √∫nico archivo en disco Sistema de archivos gestionado por servidor Usuarios Sin usuarios (usa permisos del archivo) Sistema interno de usuarios y roles Concurrencia Limitada (pocas escrituras simult√°neas) Alta (miles de usuarios simult√°neos) Uso Ideal Apps locales, dispositivos, tr√°fico bajo Sistemas empresariales, web masiva <p>Nota: El \"3\" en SQLite3 se refiere a la versi√≥n 3 del software, que es el est√°ndar actual estable y el m√°s utilizado globalmente.</p>","path":["SQL","Definici√≥n de SQLite3"],"tags":[]},{"location":"sql/sqlite/#buenas-practicas-y-sintaxis","level":2,"title":"Buenas Pr√°cticas y Sintaxis","text":"<p>Esto es clave para que tu c√≥digo no d√© errores tontos.</p>","path":["SQL","Definici√≥n de SQLite3"],"tags":[]},{"location":"sql/sqlite/#comillas-simples-vs-dobles","level":3,"title":"Comillas Simples vs. Dobles:","text":"<p>'Texto': √ösalas siempre para datos (strings). Ejemplo: WHERE titulo = 'El Principito'.</p> <p>\"Identificador\": √ösalas para nombres de tablas o columnas que tengan espacios o caracteres raros (aunque es mejor evitar poner nombres raros a las tablas).</p>","path":["SQL","Definici√≥n de SQLite3"],"tags":[]},{"location":"sql/sqlite/#alias-as","level":3,"title":"Alias (AS)","text":"<p>Cuando usas funciones, el nombre de la columna resultado queda feo (ej: AVG(calificacion)).</p> <p>Sin Alias: La columna se llama AVG(calificacion).</p> <p>Con Alias: SELECT AVG(calificacion) AS Promedio ... -&gt; La columna se llamar√° \"Promedio\". Esto es vital cuando tus datos van a ser le√≠dos por otro programa o mostrados en un reporte.</p>","path":["SQL","Definici√≥n de SQLite3"],"tags":[]},{"location":"sql/sqlite/#el-flujo-logico-de-una-consulta","level":3,"title":"El flujo l√≥gico de una consulta","text":"<p>Aunque t√∫ lo escribes en un orden, SQL lo \"piensa\" as√≠:</p> <ul> <li>FROM &amp; JOIN (¬øDe d√≥nde saco los datos?)</li> <li>WHERE (Filtrar filas)</li> <li>GROUP BY (Agrupar)</li> <li>HAVING (Filtrar grupos)</li> <li>SELECT (¬øQu√© columnas muestro?)</li> <li>ORDER BY (Ordenar resultados)</li> <li>LIMIT (Limitar cantidad)</li> </ul>","path":["SQL","Definici√≥n de SQLite3"],"tags":[]},{"location":"sql/sqlite/#select","level":2,"title":"<code>SELECT</code>","text":"<p>El comando <code>SELECT</code> es la base de todo, nos permite seleccionar las columnas que que queremos de la tabla seleccionada.</p> <pre><code>SELECT \"author\", \"title\" FROM \"books\";\n-- Esto nos trae todas las filas de las columnas espec√≠ficadas.\nSELECT * FROM \"books\";\n-- Tambi√©n podemos pedir mediante el asterisco todo los registro de la base de datos.\nSELECT * FROM \"books\" LIMIT 5;\n-- Con Limit podemos estipular cuantas filas queremos.\n</code></pre> <p>Es recomendable no abusar del <code>*</code>, ya que en bases de datos con muchos datos, al traer todos los datos de la misma, puede ser muy lento, y por tanto poco eficiente.</p>","path":["SQL","Definici√≥n de SQLite3"],"tags":[]},{"location":"sql/sqlite/#filtrado-de-datos","level":2,"title":"Filtrado de datos","text":"<p>Con la ayuda de la cl√°usula <code>WHERE</code> podemos decidir que filas ver.</p> <p>¬øC√≥mo funciona esto? La base de datos revisa fila por fila de las requeridas preguntando si la misma cumple la condici√≥n establecida.</p> <p>Tambi√©n tenemos operadores l√≥gicos: <code>AND</code>, <code>OR</code>, <code>NOT</code></p> <pre><code>SELECT \"title\", \"year\" FROM \"books\"\nWHERE \"year\" = 2021 or \"year\" = 2022;\n--Tambi√©n para rangos, tenemos el BETWEEN\n-- Con between ser√≠a WHERE \"year\" BETWEEN 2021 AND 2022;\n</code></pre> <p>En el caso de que la tabla books tuviera un campo / columna year (a√±o de publicaci√≥n del libro). Si solo queremos los que salieron entre el a√±o 2021 y el 2022 podemos combinar el where con un or. OJO: No un and, ya que si miramos una fila concreta y primero preguntamos year es igual a 2021 y la respuesta es si, ya no es posible que ese year sea 2022. En cambio con el or, si no es igual a 2021, revisa si es 2022, y si es alguno de los dos, obtine la fila.</p> <p>Tambi√©n se pueda usar par√©ntesis, por ejemplo, para mezclar conjuntos de condiciones.</p> <p>Tambi√©n podemos filtrar por <code>NULL</code>. Si un campo es nulo o no lo es.  ¬øQu√© quiere decir esto? que ese dato en concreto es desconocido o presenta ausencia de valor.</p> <pre><code>SELECT \"tile\", \"translator\" FROM \"books\";\n-- Esto nos devolvera todos los campos, algunos de translator vendr√°n como NULL porque ese libro no habr√°n libros que no tengan traducci√≥n.\n\nSELECT \"title\", \"translator\" FROM \"books\"\nWHERE \"translator\" IS NOT NULL;\n-- Esto trae todos las filas en la que ese campo no es Nulo. Para obter los nulos ser√≠a igual pero con IS NULL\n</code></pre>","path":["SQL","Definici√≥n de SQLite3"],"tags":[]},{"location":"sql/sqlite/#busqueda-de-patrones","level":3,"title":"B√∫squeda de patrones","text":"<p>Para buscar coincidencias no exactas en las cadenas de texto almacenadas en la base de datos se utilizan principalmente los operadores <code>LIKE</code> y los comodines (<code>%</code> y <code>_</code>).</p> <p>Estos permiten filtrar resultados cuando no conocemos el valor exacto del texto.</p>","path":["SQL","Definici√≥n de SQLite3"],"tags":[]},{"location":"sql/sqlite/#operador-like","level":3,"title":"Operador <code>LIKE</code>","text":"<p>El operador <code>LIKE</code> se usa en la cl√°usula <code>WHERE</code> para comparar una columna de texto con un patr√≥n.</p> <p>Sintaxis b√°sica</p> <pre><code>SELECT \"title\" \nFROM \"books\"\nWHERE \"title\" LIKE 'The %';\n-- Empieza por The y puede acabar por cualquier cosa\n</code></pre>","path":["SQL","Definici√≥n de SQLite3"],"tags":[]},{"location":"sql/sqlite/#ordenamiento","level":2,"title":"Ordenamiento","text":"<p>Para ordenar las filas resultantes de una consulta utilizamos la cl√°usula <code>ORDER BY</code>.</p> <pre><code>SELECT \"tile\", \"year\", \"rating\" FROM libros\nORDER BY \"year\" DESC, \"rating\" DESC;\n-- Criterio 1: Ordena primero por 'year' (los m√°s recientes arriba).\n-- Criterio 2: Si dos libros son del mismo a√±o (empate), usa 'rating' para desempatar (el mejor valorado primero).\n</code></pre> <p>ASC (Ascendente): Es el valor por defecto. Si no escribes nada, SQL asume este orden.</p> <p>N√∫meros: De menor a mayor (1, 2, 3...).</p> <p>Texto: De la A a la Z.</p> <p>DESC (Descendente): Debes especificarlo expl√≠citamente.</p> <p>N√∫meros: De mayor a menor (10, 9, 8...).</p> <p>Texto: De la Z a la A.</p>","path":["SQL","Definici√≥n de SQLite3"],"tags":[]},{"location":"sql/sqlite/#funciones-de-agregacion","level":2,"title":"Funciones de agregaci√≥n","text":"<p>Estas funciones toman muchas filas y las \"aplastan\" para devolverte un solo dato resumen.</p> <ul> <li> <p>COUNT     <pre><code>COUNT(*) VS COUNT(\"translator\")\n\nEl primero cuenta filas totales y el segundo cuenta las filas en las que el valor no es nulo.\n</code></pre></p> </li> <li> <p>AVG</p> <p><code>Nos devuelve la media de todos los registros de una columna</code></p> </li> <li> <p>MIN</p> <p><code>Nos devuelve el valor m√≠nimo de la columna selecciona</code></p> </li> <li> <p>MAX</p> <p><code>Nos devuelve el valor m√°ximo de la columna selecciona</code></p> </li> <li> <p>SUM</p> <p><code>Suma todos los valores de una columna</code></p> </li> </ul> <p>Podemos usar ROUND(\"valor\", 2), para redondear un resultado decimal, el 2 puede variar al n√∫mero de decimales que se desee</p>","path":["SQL","Definici√≥n de SQLite3"],"tags":[]},{"location":"sql/sqlite/#valores-unicos","level":2,"title":"Valores √önicos","text":"<p>Sirve para responder preguntas como: \"¬øCu√°ntos autores diferentes tengo?\".</p> <ul> <li> <p>Sin DISTINCT: SELECT \"author\" FROM \"books\"; -&gt; Si tienes 10 libros de J.K. Rowling, su nombre saldr√° 10 veces.</p> </li> <li> <p>Con DISTINCT: SELECT DISTINCT \"author\" FROM \"books\"; -&gt; Su nombre saldr√° solo una vez.</p> </li> </ul> <pre><code>SELECT COUNT(DISTINCT autor) FROM libros;\n-- Cuenta cu√°ntos autores √∫nicos existen en la base de datos.\n</code></pre>","path":["SQL","Definici√≥n de SQLite3"],"tags":[]},{"location":"sql/sqlite/#la-importancia-del-modelo-relacional","level":2,"title":"La importancia del modelo relacional","text":"<p>Cuando usamos una sola tabla para todo (como una hoja de c√°lculo gigante), parece m√°s f√°cil al principio porque \"lo ves todo junto\". Sin embargo, esto genera tres problemas graves que destruyen la calidad de tus datos a largo plazo.</p> <p>Supongamos que tenemos esta tabla √∫nica de Libros:</p> T√≠tulo Autor Email Autor Editorial Direcci√≥n Editorial Harry Potter 1 J.K. Rowling jk@rowling.com Salamandra Calle Falsa 123 Harry Potter 2 J.K. Rowling jk@rowling.com Salamandra Calle Falsa 123 Harry Potter 3 J.K. Rowling jk@rowling.com Salamandra Calle Falsa 123 El Principito Saint-Exup√©ry ant@exupery.fr Salamandra Calle Falsa 123 <p>Redundancia de Datos (Desperdicio de Espacio)</p> <p>El Problema: F√≠jate en la tabla de arriba. Hemos escrito \"J.K. Rowling\", su email, \"Salamandra\" y la direcci√≥n \"Calle Falsa 123\" repetidas veces.</p> <p>La Consecuencia: Si la biblioteca tiene 1 mill√≥n de libros, estar√°s guardando millones de veces la misma direcci√≥n de la editorial. Esto hace que la base de datos sea pesada, lenta y costosa de almacenar.</p> <p>La Pesadilla de la Actualizaci√≥n (Anomal√≠a de Modificaci√≥n)</p> <p>Este es el problema m√°s peligroso.</p> <p>El Escenario: Imagina que la Editorial Salamandra se muda de \"Calle Falsa 123\" a \"Avenida Real 45\".</p> <p>En una sola tabla: Tienes que buscar todas las filas donde aparezca \"Salamandra\" (quiz√°s sean 50.000 libros) y cambiar la direcci√≥n una por una.</p> <p>El Riesgo: Si el sistema falla a la mitad o se te olvida una fila, tendr√°s datos corruptos: algunos libros dir√°n que la editorial est√° en la calle vieja y otros en la nueva. Tu base de datos ha dejado de ser confiable.</p> <p>Rigidez de Datos (Anomal√≠a de Inserci√≥n)</p> <p>El Problema: En una tabla √∫nica, no puedes guardar informaci√≥n sobre algo si no tienes el dato completo de la fila.</p> <p>Ejemplo: Quieres registrar a un nuevo autor prometedor en tu base de datos, pero a√∫n no ha publicado ning√∫n libro.</p> <p>El Bloqueo: Como la tabla es de \"Libros\", no puedes crear una fila solo para el autor (o tendr√≠as que dejar el t√≠tulo como NULL, lo cual es sucio). El sistema te obliga a inventar un libro falso o a no guardar al autor.</p> <p>La Soluci√≥n: El Modelo Relacional (Varias Tablas)</p> <p>La soluci√≥n es dividir la informaci√≥n en entidades l√≥gicas (autores, editoriales, libros) y conectarlas mediante IDs.</p> <ul> <li>Ventajas Inmediatas:</li> </ul> <p>Fuente √önica de la Verdad (SSOT):   La direcci√≥n de \"Salamandra\" se escribe una sola vez en la tabla publishers.</p> <p>Si se mudan, solo cambias ese dato una vez. Autom√°ticamente, los 50.000 libros que apuntan a ese ID de editorial estar√°n \"actualizados\" porque simplemente est√°n leyendo la referencia.</p> <ul> <li>Eficiencia:</li> </ul> <p>En lugar de repetir el texto \"J.K. Rowling\" (12 bytes) millones de veces, solo repites el n√∫mero 1 (4 bytes). El ahorro de espacio es gigantesco.</p> <ul> <li>Flexibilidad:</li> </ul> <p>Puedes a√±adir un autor a la tabla authors aunque no tenga libros todav√≠a. Existe independientemente.</p>","path":["SQL","Definici√≥n de SQLite3"],"tags":[]},{"location":"sql/sqlite/#tipos-de-relaciones","level":2,"title":"Tipos de Relaciones","text":"<p>Uno a Uno (One-to-One): Un autor escribe solo un libro y un libro es escrito por solo un autor (poco com√∫n en la realidad).</p> <p>Uno a Muchos (One-to-Many): Un editor (publisher) publica muchos libros, pero un libro espec√≠fico pertenece a un solo editor.</p> <p>Muchos a Muchos (Many-to-Many): Un autor puede escribir muchos libros, y un libro puede tener m√∫ltiples autores (coautores).</p>","path":["SQL","Definici√≥n de SQLite3"],"tags":[]},{"location":"sql/sqlite/#diagramas-er-entity-relationship","level":3,"title":"Diagramas ER (Entity Relationship)","text":"<p>Se usan para visualizar estas relaciones. Se utiliza la Notaci√≥n de Pata de Gallo (Crow's Foot notation):</p> <ul> <li>L√≠nea simple: Relaci√≥n \"Uno\".</li> <li>Pata de gallo (tres l√≠neas): Relaci√≥n \"Muchos\".</li> <li>C√≠rculo: Opcional (Cero).</li> </ul>","path":["SQL","Definici√≥n de SQLite3"],"tags":[]},{"location":"sql/sqlite/#keys-claves-el-pegamento-de-los-datos","level":2,"title":"Keys (Claves): El Pegamento de los Datos","text":"<p>Las claves son el mecanismo que permite que las relaciones funcionen. Sin ellas, las tablas ser√≠an islas aisladas.</p> <ul> <li>A. Primary Key (PK) - La Identidad   Qu√© es: Es la columna que identifica de forma √∫nica e irrepetible a cada fila de una tabla.</li> </ul> <p>Reglas:</p> <ul> <li>Nunca puede ser NULL (vac√≠o).</li> <li>Nunca puede repetirse.</li> </ul> <p>Mejor Pr√°ctica: Aunque existen identificadores naturales (como el DNI o ISBN), en bases de datos casi siempre usamos un n√∫mero entero autoincremental (id: 1, 2, 3...) porque es m√°s r√°pido para el ordenador procesarlo.</p> <ul> <li>B. Foreign Key (FK) - La Referencia   Qu√© es: Es una columna que apunta a la Primary Key de otra tabla. Es como guardar un \"link\" o acceso directo hacia otra fila.</li> </ul> <p>Funci√≥n: Crea la restricci√≥n de integridad referencial. (No puedes poner un publisher_id = 99 si la editorial 99 no existe en la tabla de editoriales).</p> <p>Ejemplo pr√°ctico de conexi√≥n entre tablas (PK y FK)   Tabla: Editoriales (publishers)</p> <p>La Primary Key (PK) es id, identifica de forma √∫nica a cada editorial.</p> id (PK) nombre 5 Salamandra 6 Anagrama <p>Tabla: Libros (books)</p> <p>Aqu√≠ id es la Primary Key (PK) y publisher_id es la Foreign Key (FK) que apunta a publishers.id.</p> id (PK) titulo publisher_id (FK) 101 Harry Potter 5 102 El Principito 5 103 Seda 6 <ul> <li>Interpretaci√≥n (c√≥mo lo entiende SQL)</li> <li>El libro con id = 101 tiene publisher_id = 5</li> <li>SQL va a la tabla publishers</li> <li>Busca id = 5</li> <li>Encuentra Salamandra</li> <li>Conclusi√≥n: ‚ÄúHarry Potter es de la editorial Salamandra‚Äù</li> </ul> <p>El n√∫mero 5 es el pegamento que conecta ambas tablas.</p>","path":["SQL","Definici√≥n de SQLite3"],"tags":[]},{"location":"sql/sqlite/#subconsultas-subqueries","level":2,"title":"Subconsultas (Subqueries)","text":"<p>Son consultas anidadas (una dentro de otra). Se usan cuando necesitas un dato de otra tabla para completar tu filtro.</p> <p>Sintaxis B√°sica La consulta interna (entre par√©ntesis) se ejecuta primero.</p> <p>Ejemplo: Encontrar todos los libros publicados por \"Fitzcarraldo Editions\".</p> <ul> <li>Primero necesitamos el ID de la editorial.</li> <li>Luego usamos ese ID para buscar los libros.</li> </ul> <pre><code>SELECT title \nFROM books \nWHERE publisher_id = (\n    SELECT id \n    FROM publishers \n    WHERE publisher = 'Fitzcarraldo Editions'\n);\n</code></pre>","path":["SQL","Definici√≥n de SQLite3"],"tags":[]},{"location":"sql/sqlite/#el-operador-in","level":3,"title":"El Operador IN","text":"<p>Si la subconsulta devuelve m√°s de un resultado (ej. un autor con m√∫ltiples IDs o m√∫ltiples libros), no podemos usar =, debemos usar IN.</p> <p>Ejemplo: Encontrar libros de la autora \"Fernanda Melchor\".</p> <pre><code>SELECT title \nFROM books \nWHERE id IN (\n    SELECT book_id \n    FROM authored \n    WHERE author_id = (\n        SELECT id \n        FROM authors \n        WHERE name = 'Fernanda Melchor'\n    )\n);\n</code></pre> <p>Consejo de estilo: Es recomendable indentar las subconsultas para facilitar la lectura.</p>","path":["SQL","Definici√≥n de SQLite3"],"tags":[]},{"location":"sql/sqlite/#joins-uniones-de-tablas","level":2,"title":"JOINs (Uniones de Tablas)","text":"<p>Las subconsultas son √∫tiles, pero JOIN permite combinar filas de dos o m√°s tablas en una sola tabla de resultados temporal.</p> <p>Sintaxis JOIN (o INNER JOIN) Combina tablas bas√°ndose en una columna com√∫n. Solo muestra filas donde hay coincidencia en ambas tablas.</p> <p>Ejemplo (Base de datos de Leones Marinos): Queremos ver qu√© leones marinos (sea_lions) tenemos rastreados en la tabla de migraciones (migrations).</p> <pre><code>SELECT * FROM sea_lions\nJOIN migrations ON migrations.id = sea_lions.id;\n</code></pre> <p>Tipos de JOIN</p> <ul> <li> <p>INNER JOIN (Por defecto): Excluye filas que no tienen pareja en la otra tabla (ej. un le√≥n marino sin datos de migraci√≥n desaparece del resultado).</p> </li> <li> <p>LEFT JOIN: Muestra todas las filas de la tabla izquierda (la primera mencionada), aunque no tengan coincidencia en la derecha (rellena con NULL).</p> </li> </ul> <pre><code>SELECT * FROM sea_lions LEFT JOIN migrations ON ...\n</code></pre> <ul> <li> <p>RIGHT JOIN: Muestra todas las filas de la tabla derecha, aunque no tengan coincidencia en la izquierda.</p> </li> <li> <p>FULL JOIN: Muestra todo de ambas tablas, rellenando con NULL donde falten datos.</p> </li> <li> <p>NATURAL JOIN   Es un atajo. Si las dos tablas tienen una columna con el mismo nombre (ej. ambas tienen una columna id), SQL las une autom√°ticamente sin que escribas la cl√°usula ON.</p> </li> </ul> <pre><code>SELECT * FROM sea_lions NATURAL JOIN migrations;\n</code></pre>","path":["SQL","Definici√≥n de SQLite3"],"tags":[]},{"location":"sql/sqlite/#operaciones-de-conjuntos-sets","level":2,"title":"Operaciones de Conjuntos (Sets)","text":"<p>SQL permite tratar los resultados como conjuntos matem√°ticos (Diagramas de Venn). Requisito: Las tablas deben tener el mismo n√∫mero y tipo de columnas.</p> <ul> <li> <p>UNION (O): Combina los resultados de dos consultas (A + B). Elimina duplicados.</p> <p>Ejemplo: Autores O Traductores.</p> </li> <li> <p>INTERSECT (Y): Devuelve solo los elementos que aparecen en ambas consultas.</p> <p>Ejemplo: Personas que son Autores Y TAMBI√âN Traductores.</p> </li> <li> <p>EXCEPT (Menos): Devuelve los elementos de la primera consulta menos los de la segunda.</p> <p>Ejemplo: Autores que NO son Traductores.</p> </li> </ul> <p>Ejemplo de sintaxis:</p> <pre><code>SELECT name FROM authors\nINTERSECT\nSELECT name FROM translators;\n</code></pre>","path":["SQL","Definici√≥n de SQLite3"],"tags":[]},{"location":"sql/sqlite/#agrupamiento-groups","level":2,"title":"Agrupamiento (Groups)","text":"<p>A veces queremos calcular estad√≠sticas por categor√≠as, no de toda la tabla.</p> <p>GROUP BY</p> <p>Agrupa filas que tienen el mismo valor en una columna especificada para aplicar funciones de agregaci√≥n (AVG, COUNT, MAX, etc.).</p> <p>Ejemplo: Calcular el promedio de calificaci√≥n (rating) por cada libro. <pre><code>SELECT book_id, AVG(rating) \nFROM ratings \nGROUP BY book_id;\n</code></pre> HAVING Es el equivalente a WHERE, pero para grupos.</p> <ul> <li> <p>WHERE: Filtra filas individuales antes de agrupar.</p> </li> <li> <p>HAVING: Filtra grupos despu√©s de agrupar.</p> </li> </ul> <p>Ejemplo: Mostrar solo los libros con un promedio de calificaci√≥n mayor a 4.0.</p> <pre><code>SELECT book_id, AVG(rating) \nFROM ratings \nGROUP BY book_id \nHAVING AVG(rating) &gt; 4.0;\n</code></pre>","path":["SQL","Definici√≥n de SQLite3"],"tags":[]},{"location":"sql/sqlite/#diseno-de-bases-de-datos-relacionales","level":2,"title":"Dise√±o de Bases de Datos Relacionales","text":"<p>El dise√±o de bases de datos es el proceso de definir la estructura l√≥gica (el \"plano\" o schema) que organizar√° los datos. El objetivo es asegurar la integridad, reducir la redundancia y facilitar el acceso a la informaci√≥n.</p>","path":["SQL","Definici√≥n de SQLite3"],"tags":[]},{"location":"sql/sqlite/#normalizacion-de-datos","level":3,"title":"Normalizaci√≥n de Datos","text":"<p>La normalizaci√≥n es el proceso de organizar los datos en tablas para minimizar la redundancia y evitar anomal√≠as en la inserci√≥n, actualizaci√≥n o borrado de datos.</p>","path":["SQL","Definici√≥n de SQLite3"],"tags":[]},{"location":"sql/sqlite/#el-problema-de-la-tabla-unica-desnormalizacion","level":4,"title":"El Problema de la Tabla √önica (Desnormalizaci√≥n)","text":"<p>Almacenar toda la informaci√≥n en una sola tabla provoca duplicidad de datos y dificulta el mantenimiento.</p> <p>Ejemplo de mal dise√±o (Sistema de Metro): Imagina una tabla √∫nica <code>movimientos_metro</code> que registra cada vez que alguien pasa una tarjeta.</p> Pasajero Estaci√≥n L√≠nea Acci√≥n Saldo Juan P√©rez Central Roja Entrar 2.50 Ana G√≥mez Norte Verde Salir 5.00 Juan P√©rez Sur Azul Entrar 1.00 <ul> <li> <p>Redundancia: El nombre \"Juan P√©rez\" se repite. Si Juan cambia su nombre, hay que actualizar m√∫ltiples filas.</p> </li> <li> <p>Ambig√ºedad: Si hay dos \"Juan P√©rez\", no podemos distinguirlos.</p> </li> <li> <p>Ineficiencia: Guardamos el nombre de la l√≠nea (\"Roja\") cada vez que alguien entra en la estaci√≥n \"Central\", gastando espacio innecesariamente.</p> </li> </ul>","path":["SQL","Definici√≥n de SQLite3"],"tags":[]},{"location":"sql/sqlite/#la-solucion-entidades-y-relaciones","level":4,"title":"La Soluci√≥n: Entidades y Relaciones","text":"<p>Separamos los conceptos en Entidades (tablas propias):</p> <ol> <li> <p>Pasajeros (Riders): Informaci√≥n √∫nica de la persona.</p> </li> <li> <p>Estaciones (Stations): Informaci√≥n √∫nica del lugar.</p> </li> <li> <p>Transacciones (Visits/Swipes): El evento que conecta a ambos.</p> </li> </ol>","path":["SQL","Definici√≥n de SQLite3"],"tags":[]},{"location":"sql/sqlite/#tipos-de-datos-en-sqlite-clases-y-afinidades","level":3,"title":"Tipos de Datos en SQLite: Clases y Afinidades","text":"<p>SQLite es √∫nico porque utiliza un sistema de Tipado Din√°mico. A diferencia de otros motores SQL (como PostgreSQL o MySQL) donde el tipo de dato se fija r√≠gidamente en la columna, SQLite se fija en el valor en s√≠ mismo, utilizando dos conceptos clave:</p>","path":["SQL","Definici√≥n de SQLite3"],"tags":[]},{"location":"sql/sqlite/#a-clases-de-almacenamiento-storage-classes","level":4,"title":"A. Clases de Almacenamiento (Storage Classes)","text":"<p>Es c√≥mo se guardan f√≠sicamente los datos en el disco duro. SQLite solo tiene 5 clases fundamentales:</p> <ol> <li>NULL: Representa la ausencia de valor.</li> <li>INTEGER: N√∫meros enteros con signo (1, 2, -50). Se usan para IDs, contadores o cantidades exactas. Ocupan 1, 2, 3, 4, 6, u 8 bytes dependiendo de la magnitud.</li> <li>REAL: N√∫meros de punto flotante IEEE (decimales como 3.14, -0.01). Se usan para mediciones f√≠sicas.</li> <li>TEXT: Cadenas de caracteres (UTF-8, UTF-16). Nombres, descripciones.</li> <li>BLOB (Binary Large Object): Datos binarios almacenados tal cual se introducen (im√°genes, archivos, audio).</li> </ol>","path":["SQL","Definici√≥n de SQLite3"],"tags":[]},{"location":"sql/sqlite/#b-afinidades-de-tipo-type-affinity","level":4,"title":"B. Afinidades de Tipo (Type Affinity)","text":"<p>Cuando creas una tabla (<code>CREATE TABLE</code>), defines un tipo para la columna. SQLite mapea ese tipo declarado a una de las 5 \"Afinidades\". La afinidad es la preferencia de la columna sobre c√≥mo guardar el dato.</p> <p>Las 5 Afinidades son:</p> <ol> <li>TEXT: Preferida para columnas declaradas como <code>VARCHAR</code>, <code>TEXT</code>, <code>CLOB</code>.<ul> <li>Comportamiento: Si intentas guardar un n√∫mero, lo convierte a texto.</li> </ul> </li> <li>NUMERIC: Preferida para columnas declaradas como <code>NUMERIC</code>, <code>DECIMAL</code>, <code>DATE</code>.<ul> <li>Comportamiento: Intenta convertir texto a INTEGER o REAL si es posible. Si insertas <code>'10.5'</code>, lo guarda como n√∫mero <code>10.5</code>. Si insertas <code>'hola'</code>, lo guarda como texto.</li> </ul> </li> <li>INTEGER: Preferida para columnas declaradas como <code>INT</code>, <code>INTEGER</code>, <code>BIGINT</code>.<ul> <li>Comportamiento: Se comporta como NUMERIC, pero si el n√∫mero tiene decimales y cabe en un entero (ej: <code>10.0</code>), lo convierte a entero (<code>10</code>).</li> </ul> </li> <li>REAL: Preferida para columnas declaradas como <code>REAL</code>, <code>DOUBLE</code>, <code>FLOAT</code>.<ul> <li>Comportamiento: Fuerza la conversi√≥n a punto flotante.</li> </ul> </li> <li>BLOB: Preferida para columnas declaradas como <code>BLOB</code> o si no se especifica tipo.<ul> <li>Comportamiento: No intenta convertir nada. Guarda el dato tal cual llega.</li> </ul> </li> </ol> <p>Ejemplo de Conversi√≥n (Coerci√≥n de Tipos):</p> <ul> <li> <p>Si tienes una columna con afinidad INTEGER.</p> </li> <li> <p>Insertas el texto <code>'150'</code>.</p> </li> <li> <p>SQLite detecta que parece un n√∫mero -&gt; Lo convierte y lo guarda como el n√∫mero <code>150</code> (Clase INTEGER).</p> </li> <li> <p>Si insertas <code>'Cien'</code>, no puede convertirlo -&gt; Lo guarda como <code>'Cien'</code> (Clase TEXT).</p> </li> </ul> <p>Consejo Pro: Para datos monetarios, se recomienda usar INTEGER (almacenando centavos) en lugar de REAL para evitar errores de redondeo de punto flotante.</p>","path":["SQL","Definici√≥n de SQLite3"],"tags":[]},{"location":"sql/sqlite/#data-definition-language-ddl","level":3,"title":"Data Definition Language (DDL)","text":"<p>DDL son los comandos SQL utilizados para definir y modificar la estructura de la base de datos.</p>","path":["SQL","Definici√≥n de SQLite3"],"tags":[]},{"location":"sql/sqlite/#crear-tablas-create-table","level":4,"title":"Crear Tablas (CREATE TABLE)","text":"<p>Define el nombre de la tabla, sus columnas y los tipos de datos preferidos.</p> <pre><code>CREATE TABLE riders (\n    id INTEGER,\n    name TEXT\n);\n</code></pre>","path":["SQL","Definici√≥n de SQLite3"],"tags":[]},{"location":"sql/sqlite/#modificar-tablas-alter-table","level":4,"title":"Modificar Tablas (ALTER TABLE)","text":"<p>Permite cambiar la estructura de una tabla existente sin perder sus datos. <pre><code>-- Renombrar tabla:\n\nALTER TABLE riders RENAME TO passengers;\n\n--A√±adir columna:\n\nALTER TABLE passengers ADD COLUMN email TEXT;\n\n--Renombrar columna:\n\nALTER TABLE passengers RENAME COLUMN name TO full_name;\n\n--Eliminar columna:\n\nALTER TABLE passengers DROP COLUMN email;\n</code></pre></p>","path":["SQL","Definici√≥n de SQLite3"],"tags":[]},{"location":"sql/sqlite/#eliminar-tabla-drop-table","level":4,"title":"Eliminar tabla (DROP TABLE)","text":"<p>Eliminar Tablas (DROP TABLE) Borra la tabla y todos sus datos permanentemente.</p> <pre><code>DROP TABLE passengers;\n</code></pre>","path":["SQL","Definici√≥n de SQLite3"],"tags":[]},{"location":"sql/sqlite/#restricciones-de-integridad-constraints","level":2,"title":"Restricciones de Integridad (Constraints)","text":"<p>Las restricciones son reglas que la base de datos impone para garantizar la validez, precisi√≥n y consistencia de los datos.</p>","path":["SQL","Definici√≥n de SQLite3"],"tags":[]},{"location":"sql/sqlite/#restricciones-de-tabla-identidad-y-relacion","level":3,"title":"Restricciones de Tabla (Identidad y Relaci√≥n)","text":"<p>PRIMARY KEY (Clave Primaria):</p> <ul> <li> <p>Columna (o grupo de columnas) que identifica de forma √∫nica a cada fila de la tabla.</p> </li> <li> <p>Implica <code>UNIQUE</code> y <code>NOT NULL</code>.</p> </li> <li> <p>Es la base para buscar registros r√°pidamente.</p> </li> <li> <p>Convenci√≥n: Usar una columna <code>id INTEGER PRIMARY KEY</code>.</p> </li> </ul> <p>FOREIGN KEY (Clave For√°nea):</p> <ul> <li> <p>Columna que crea un v√≠nculo con la <code>PRIMARY KEY</code> de otra tabla.</p> </li> <li> <p>Garantiza la Integridad Referencial: no puedes tener una transacci√≥n de una tarjeta que no existe en la tabla de tarjetas.</p> </li> </ul>","path":["SQL","Definici√≥n de SQLite3"],"tags":[]},{"location":"sql/sqlite/#restricciones-de-columna-reglas-de-datos","level":3,"title":"Restricciones de Columna (Reglas de Datos)","text":"<p>NOT NULL:</p> <ul> <li> <p>Proh√≠be que el valor sea nulo. Obligatorio tener dato.</p> </li> <li> <p>Ejemplo: Una estaci√≥n debe tener nombre.</p> </li> </ul> <p>UNIQUE:</p> <ul> <li> <p>Asegura que todos los valores de la columna sean diferentes entre s√≠.</p> </li> <li> <p>Ejemplo: No pueden existir dos tarjetas con el mismo n√∫mero de serie.</p> </li> </ul> <p>DEFAULT:</p> <ul> <li> <p>Asigna un valor predeterminado si no se especifica uno al insertar.</p> </li> <li> <p>Ejemplo: <code>DEFAULT CURRENT_TIMESTAMP</code> para guardar la hora exacta del registro autom√°ticamente.</p> </li> </ul> <p>CHECK:</p> <ul> <li> <p>Permite definir una condici√≥n l√≥gica personalizada que debe cumplirse. Es muy potente para validar reglas de negocio.</p> </li> <li> <p>Ejemplo: El saldo no puede ser negativo (<code>amount &gt;= 0</code>).</p> </li> <li> <p>Ejemplo: El tipo de transacci√≥n solo puede ser uno de una lista (<code>IN ('enter', 'exit')</code>).</p> </li> </ul>","path":["SQL","Definici√≥n de SQLite3"],"tags":[]},{"location":"sql/sqlite/#ejemplo-practico-de-diseno-completo","level":2,"title":"Ejemplo Pr√°ctico de Dise√±o Completo","text":"<p>(Caso: Tarjeta de Transporte)</p> <p>A continuaci√≥n, un esquema robusto que aplica todos los conceptos anteriores para un sistema de tarjetas de metro (como la \"CharlieCard\").</p> <ul> <li>Entidad 1: Tarjetas (Cards) Identificamos a los usuarios por su tarjeta, no por su nombre (anonimato/seguridad).</li> </ul> <pre><code>CREATE TABLE cards (\n    id INTEGER PRIMARY KEY\n);\n</code></pre> <ul> <li>Entidad 2: Estaciones (Stations) Cat√°logo de lugares. El nombre debe ser √∫nico para evitar confusiones.</li> </ul> <pre><code>CREATE TABLE stations (\n    id INTEGER PRIMARY KEY,\n    name TEXT NOT NULL UNIQUE,\n    line TEXT NOT NULL\n);\n</code></pre> <ul> <li>Entidad 3: Transacciones (Swipes) - La tabla \"Asociativa\" Esta tabla conecta Tarjetas con Estaciones y registra eventos. Implementa m√∫ltiples restricciones para asegurar la calidad del dato.</li> </ul> <pre><code>CREATE TABLE swipes (\n    id INTEGER PRIMARY KEY,\n\n    -- Claves For√°neas: Conexi√≥n con las otras tablas\n    card_id INTEGER,\n    station_id INTEGER,\n\n    -- Tipo de transacci√≥n validada con CHECK\n    type TEXT NOT NULL CHECK(type IN ('enter', 'exit', 'deposit')),\n\n    -- Fecha y hora autom√°tica\n    datetime NUMERIC NOT NULL DEFAULT CURRENT_TIMESTAMP,\n\n    -- Dinero manejado (no permitimos transacciones de valor 0)\n    amount NUMERIC NOT NULL CHECK(amount != 0),\n\n    -- Definici√≥n expl√≠cita de las relaciones\n    FOREIGN KEY(card_id) REFERENCES cards(id),\n    FOREIGN KEY(station_id) REFERENCES stations(id)\n);\n</code></pre>","path":["SQL","Definici√≥n de SQLite3"],"tags":[]},{"location":"sql/sqlite/#modelado-de-relaciones","level":2,"title":"Modelado de Relaciones","text":"<p>Al dise√±ar, debemos identificar c√≥mo interact√∫an las entidades:</p> <p>Uno a Uno (1:1):</p> <ul> <li> <p>Una fila en la tabla A corresponde a una √∫nica fila en la tabla B.</p> </li> <li> <p>Nota: Es poco com√∫n; normalmente si tienen relaci√≥n 1:1 se suelen unir los datos en una sola tabla.</p> </li> </ul> <p>Uno a Muchos (1:M):</p> <ul> <li> <p>Una fila en la tabla A se relaciona con muchas filas en la tabla B.</p> </li> <li> <p>Ejemplo: Una L√≠nea de metro tiene muchas Estaciones.</p> </li> <li> <p>Implementaci√≥n: La <code>FOREIGN KEY</code> se coloca en la tabla del lado \"Muchos\" (la estaci√≥n tendr√≠a una columna <code>line_id</code>).</p> </li> </ul> <p>Muchos a Muchos (M:N):</p> <ul> <li> <p>Muchas filas en la tabla A se relacionan con muchas filas en la tabla B.</p> </li> <li> <p>Ejemplo: Un Pasajero visita muchas Estaciones, y una Estaci√≥n recibe muchos Pasajeros.</p> </li> <li> <p>Implementaci√≥n: Se requiere crear una Tabla Intermedia (como la tabla <code>swipes</code> del ejemplo anterior) que contenga las claves for√°neas de ambas entidades para unirlas.</p> </li> </ul>","path":["SQL","Definici√≥n de SQLite3"],"tags":[]}]}